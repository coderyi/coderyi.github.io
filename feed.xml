<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>coderyi</title>
    <description>生命不止，折腾不息</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 21 Jan 2023 22:19:57 +0800</pubDate>
    <lastBuildDate>Sat, 21 Jan 2023 22:19:57 +0800</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>Weex学习与实践(三):iOS原理篇</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex1/&quot;&gt;Weex学习与实践(一):Weex,你需要知道的事&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex2/&quot;&gt;Weex学习与实践(二):iOS集成的tips&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex3/&quot;&gt;Weex学习与实践(三):iOS原理篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍包括WeexSDK-iOS主要类介绍、Weex页面iOS端渲染流程、JS调用iOS方法&lt;/p&gt;

&lt;h3 id=&quot;主要类&quot;&gt;主要类&lt;/h3&gt;

&lt;h4 id=&quot;wxsdkengine&quot;&gt;WXSDKEngine&lt;/h4&gt;

&lt;p&gt;WXSDKEngine主要用于初始化WeexSDK的环境&lt;/p&gt;

&lt;p&gt;一开始会载入配置文件main.js并且注册一些默认的组件、模块以及handler&lt;/p&gt;

&lt;pre&gt;
+ (void)initSDKEnviroment:(NSString *)script
{
   
    [self _registerDefaultComponents];
    [self _registerDefaultModules];
    [self _registerDefaultHandlers];
    
    [[WXSDKManager bridgeMgr] executeJsFramework:script];
}

&lt;/pre&gt;

&lt;p&gt;在executeJsFramework前，会设置后JSContext的一些回调，例如&lt;/p&gt;
&lt;pre&gt;
    _jsContext[@&quot;callNative&quot;] = callNativeBlock;
&lt;/pre&gt;
&lt;p&gt;以方便JS调用native的方法。&lt;/p&gt;

&lt;p&gt;executeJsFramework调用的是JSContext的evaluateScript方法，把main.js运行到jS的环境里面，之后再通过JSValue调用invokeMethod方法，把前面所有的components，modules，handlers注册进入JS环境&lt;/p&gt;

&lt;h4 id=&quot;wxsdkinstance&quot;&gt;WXSDKInstance&lt;/h4&gt;

&lt;p&gt;一个WXSDKInstance就对应一个UIViewController,对应一个weex页面。&lt;/p&gt;

&lt;p&gt;主要用来渲染页面,一般通过renderWithURL方法，然后能够接收一些回调和一些视图相关的方法&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;onCreate //根视图rootView创建的时候
renderFinish//视图渲染完成
componentForRef //通过视图索引拿到对应的组件视图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;wxbridgemanager&quot;&gt;WXBridgeManager&lt;/h4&gt;

&lt;p&gt;WXBridgeManager 是JS与iOS通过JSCore交互的类,相关的类还有WXBridgeContext、WXJSCoreBridge。&lt;/p&gt;

&lt;p&gt;比如调用JS&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (void)executeJsMethod:(WXBridgeMethod *)method
{
    if (!method) return;
    
    __weak typeof(self) weakSelf = self;
    WXPerformBlockOnBridgeThread(^(){
        [weakSelf.bridgeCtx executeJsMethod:method];
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JS调用native的话需要通过WXJSCoreBridge的registerCallNative方法&lt;/p&gt;

&lt;h4 id=&quot;wxcomponent&quot;&gt;WXComponent&lt;/h4&gt;

&lt;p&gt;组件基类，自己实现iOS端的组件需要继承它。相关的还有负责组件初始化的工厂类WXComponentFactory，以及WXComponentManager&lt;/p&gt;

&lt;h4 id=&quot;wxmoduleprotocol&quot;&gt;WXModuleProtocol&lt;/h4&gt;

&lt;p&gt;自定义module需要实现的协议&lt;/p&gt;

&lt;h3 id=&quot;weex页面ios端渲染流程&quot;&gt;weex页面iOS端渲染流程&lt;/h3&gt;

&lt;p&gt;首先在ViewController里的render放初始化WXSDKInstance，因为render会支持实时刷新，所以每次都需要先销毁这个实例。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [_instance destroyInstance];
    _instance = [[WXSDKInstance alloc] init];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后WXSDKManager会保存instanceId&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        [WXSDKManager storeInstance:self forID:_instanceId];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后会调用renderWithURL方法来载入script,在这里会判断是本地文件还是需要从服务器下载，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)renderWithURL:(NSURL *)url options:(NSDictionary *)options data:(id)data{
	    if ([url isFileURL]) {
        //from local
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSString *path = [url path];
            NSData *scriptData = [[NSFileManager defaultManager] contentsAtPath:path];
            NSString *script = [[NSString alloc] initWithData:scriptData encoding:NSUTF8StringEncoding];
            [weakSelf renderView:script options:newOptions data:data];
        });
    }else{
    	//from server
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后就会根据script文件渲染视图&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[weakSelf renderView:script options:newOptions data:data];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个方法里面首先会创建根视图，当创建完成时WXSDKInstance会收到onCreate的回调&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //TODO WXRootView
    WXPerformBlockOnMainThread(^{
        self.rootView = [[WXView alloc] initWithFrame:self.frame];
        if(self.onCreate) {
            self.onCreate(self.rootView);
        }
    });

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后再通过bridge调用JS方法来开始创建实例&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [self callJSMethod:@&quot;createInstance&quot; args:args];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后这里会判断JSFramework也就是js有没有加载完成，然后再通过WXJSBridge的JSContext来执行js方法，这里调用的就是js的createInstance方法，args里面主要就是instanceID，we文件转化的js文件，和options。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)callJSMethod:(NSString *)method args:(NSArray *)args
{
    [[_jsContext globalObject] invokeMethod:method withArguments:args];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后js会调用JSContext的callCreateFinish回调，最后调用WXSDKInstance的createFinish方法来结束页面的渲染&lt;/p&gt;

&lt;h3 id=&quot;js调用ios方法&quot;&gt;JS调用iOS方法&lt;/h3&gt;

&lt;p&gt;首先要注册一个组件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [self registerModule:@&quot;dom&quot; withClass:NSClassFromString(@&quot;WXDomModule&quot;)];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注册module的时候 会通过下面方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (void)registerModule:(NSString *)name withClass:(Class)clazz
{
    WXAssert(name &amp;amp;&amp;amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;);
    
    NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];
    NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];
    
    [[WXSDKManager bridgeMgr] registerModules:dict];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把所有通过宏注册的方法发送给js端&lt;/p&gt;

&lt;pre&gt;
WX_EXPORT_METHOD(@selector(createBody:))

&lt;/pre&gt;

&lt;p&gt;这会把方法暴露出来，并且方法名字是”wx_export_method_“加代码所在行号，wx_export_method_25&lt;/p&gt;

&lt;p&gt;组件、模块 是给js端用的，而handler则是给objc自己用的，所以不用发送消息给js端&lt;/p&gt;

&lt;p&gt;然后通过methodForSelector拿到WX_EXPORT_METHOD方法的返回值，并且保存到methods中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)registerModuleMethods {

            if ([currentClass respondsToSelector:selector]) {
                method = ((NSString* (*)(id, SEL))[currentClass methodForSelector:selector])(currentClass, selector);
            }
            [_methods setObject:method forKey:name];

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后拿到WXModuleConfig组成的_moduleMap之后再发送给JS端&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [[WXSDKManager bridgeMgr] registerModules:dict];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里就是前面提到的调用JSContext的invokeMethod把内容发送到JS端&lt;/p&gt;

&lt;p&gt;最后需要自己callNative的回调，当JS调用时就会传值到这里&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)registerCallNative:(WXJSCallNative)callNative
{
    NSInteger (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^(JSValue *instance, JSValue *tasks, JSValue *callback){
        NSString *instanceId = [instance toString];
        NSArray *tasksArray = [tasks toArray];
        NSString *callbackId = [callback toString];
        
        return callNative(instanceId, tasksArray, callbackId);
    };
    
    _jsContext[@&quot;callNative&quot;] = callNativeBlock;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;tasks里面包括方法的一些相关信息,包括module（比如dom），method（比如updateFinish），args&lt;/p&gt;

&lt;h1 id=&quot;weex-devtool-ios&quot;&gt;&lt;a href=&quot;https://github.com/weexteam/weex-devtool-iOS&quot;&gt;weex-devtool-iOS&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;weex-devtool-iOS	其实是 &lt;a href=&quot;https://github.com/square/PonyDebugger&quot;&gt;PonyDebugger&lt;/a&gt;的衍生品。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.iliunian.com/2875.html&quot;&gt;使用PonyDebugger调试iOS应用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Flipboard/FLEX/blob/000e061d009bb7c64c8338f1715431ad9b5f1558/Classes/Network/PonyDebugger/FLEXNetworkObserver.m&quot;&gt;FLEXNetworkObserver&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/weex3/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/weex3/</guid>
        
        <category>Weex</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>Weex学习与实践(二):iOS集成的tips</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex1/&quot;&gt;Weex学习与实践(一):Weex,你需要知道的事&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex2/&quot;&gt;Weex学习与实践(二):iOS集成的tips&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex3/&quot;&gt;Weex学习与实践(三):iOS原理篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍包括iOS上集成Weex、iOS上扩展组件、iOS上扩展module&lt;/p&gt;

&lt;h3 id=&quot;ios上集成weex&quot;&gt;iOS上集成Weex&lt;/h3&gt;

&lt;p&gt;集成weex，需要WeexSDK、WXDevtool两个库以及阿里未开源的ATSDK-Weex。&lt;/p&gt;

&lt;p&gt;目前官方的alibaba/Weex仓库里面&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    pod 'WeexSDK', :path=&amp;gt;'../sdk/'
    pod 'WXDevtool', :path=&amp;gt;'../WXDevtool/'
    pod 'ATSDK-Weex', '0.0.1'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它们直接使用的weex仓库的sdk,但是weex主仓库的WXDevtool已经不维护了，需要替换成，&lt;a href=&quot;https://github.com/weexteam/weex-devtool-iOS&quot;&gt;weexteam/weex-devtool-iOS&lt;/a&gt;的代码。&lt;/p&gt;

&lt;p&gt;另外也可以直接从cocoapods的源pod仓库，但是cocoapods的源都是打包成framework,很多文件并没有设置为public，所以导致很多头文件没有暴露出来。&lt;/p&gt;

&lt;p&gt;当然你也可以不用通过cocoapods集成，直接把代码拉进工程就可以，如果发生&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Unknown type name 'NSString'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你可能需要把layout.c文件右侧的type改为Objective-C Source，或者直接修改为layout.m。&lt;/p&gt;

&lt;p&gt;基本上JS页面是在WXDemoViewController工作的，你可能需要接收页面刷新的通知，以支持实时刷新&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationRefreshInstance:) name:@&quot;RefreshInstance&quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;页面会维护一个WXSDKInstance实例，WXSDKInstance就是weex渲染的实例对象，提供了很多页面渲染相关的接口，比如renderWithURL、refreshInstance、destroyInstance等&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/weexteam/article/issues/18&quot;&gt;weex SDK 集成到工程 (integrate to ios) &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://open.taobao.com/doc2/detail?spm=a219a.7629140.0.0.tFddsV&amp;amp;&amp;amp;docType=1&amp;amp;articleId=104829&quot;&gt;Weex iOS SDK 集成指南&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ios上扩展组件&quot;&gt;iOS上扩展组件&lt;/h3&gt;

&lt;p&gt;目前官方iOS这一块组件的代码在WeexSDK的component里面，组件有限，只有image，list，scroller等，如果想要实现自己的组件，首先需要继承WXComponent类。&lt;/p&gt;

&lt;p&gt;然后实现方法&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance
{}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意这个方法不在主线程，这里面接收一些js传过来的参数，以在js端写的image标记为例子&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;image style=&quot;width: 100;height: 100;margin-top:20;margin-right:20;margin-left:220&quot; src=&amp;gt;&amp;lt;/image&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到objc端就是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ref:701
type:image
styles:
{
    height = 100;
    marginLeft = 220;
    marginRight = 20;
    marginTop = 20;
    width = 100;
}
attributes:
{
    src = &quot;https://avatars.githubusercontent.com/u/9892522?v=3&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ref（结点的唯一标识符）&lt;/p&gt;

&lt;p&gt;然后在loadView的时候可能需要返回自己的objc组件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (UIView *)loadView
{
    return [[WXImageView alloc] init];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后你可以通过复写addEvent方法来增加一个change（UIControlEventValueChanged）、click（UIControlEventTouchUpInside）等事件&lt;/p&gt;

&lt;p&gt;如果是image组件的话，你可能需要接收图片地址，这个时候需要通过实现了WXImgLoaderProtocol的WXImgLoaderDefaultImpl来处理，WXImgLoaderDefaultImpl实现了downloadImageWithURL方法，这里面通过SDWebImage来下载一张图片。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/weexteam/article/issues/17&quot;&gt;iOS 扩展 (extend to ios)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ios上扩展module&quot;&gt;iOS上扩展module&lt;/h3&gt;

&lt;p&gt;这一块的代码在module分组里面，包括网络库stream，持久化storage等，你可以扩展自己module。&lt;/p&gt;

&lt;p&gt;需要做的是实现WXModuleProtocol协议，并且写自己的方法就可以了，这里需要通过weex的宏把需要public的方法导出&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WX_EXPORT_METHOD(@selector(fetch:callback:progressCallback:))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在module中目前是没有view的，但是你可以通过由js传过来的ref值拿到&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    WXComponent *targetComponent = [self.weexInstance componentForRef:nodeRef];
    CALayer *layer = targetComponent.layer;
    UIView *view = targetComponent.view;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;注意点&quot;&gt;注意点&lt;/h3&gt;

&lt;p&gt;1.如果设置js文件在bundle中载入的话，需要把build的js文件拖入工程，如果的你的we里面一开始就调用了js文件，由于只会buildwe文件，所以还需要把之前的js文件拖入工程，另外examples里面判断iOSAssets是这样的&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      var isiOSAssets = bundleUrl.indexOf('file:///') &amp;gt;= 0 &amp;amp;&amp;amp; bundleUrl.indexOf('WeexDemo.app') &amp;gt; 0;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你如果拖入自己的工程需要把WeexDemo.app的判断去掉&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/weex2/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/weex2/</guid>
        
        <category>Weex</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>Weex学习与实践(一):Weex,你需要知道的事</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex1/&quot;&gt;Weex学习与实践(一):Weex,你需要知道的事&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex2/&quot;&gt;Weex学习与实践(二):iOS集成的tips&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coderyi.com/posts/weex3/&quot;&gt;Weex学习与实践(三):iOS原理篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍包括Weex基本介绍、Weex源码结构、初始化工程、we代码结构、Weex的生命周期、Weex的工作原理、页面间通信、boxmodel &amp;amp; flexbox、weex的缺点&lt;/p&gt;

&lt;h3 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h3&gt;

&lt;p&gt;A framework for building Mobile cross-platform UI&lt;/p&gt;

&lt;p&gt;怎么解释它呢？我的理解就是weex = react-native +vue ，使用vue的API风格，两端的实现方式则和react-native，weex 比rn的优点就是一次编写三端运行。&lt;/p&gt;

&lt;p&gt;IDE: Sublime Text + &lt;a href=&quot;https://github.com/vuejs/vue-syntax-highlight&quot;&gt;vue-syntax-highlight&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;命令行工具：&lt;a href=&quot;https://github.com/weexteam/weex-toolkit&quot;&gt;weex-toolkit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;调试工具: &lt;a href=&quot;https://github.com/weexteam/weex-devtool&quot;&gt;weex-devtool&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;weex分为组件component和模块（module）以及事件&lt;/p&gt;

&lt;p&gt;weex-components : &lt;a href=&quot;https://github.com/weexteam/weex-components&quot;&gt;weex-components&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;组件 就是各种标记组件，比如div 、slider、indicator等
通过下面这种方式使用&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;
  &amp;lt;image src=&quot;...&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;text&amp;gt;...&amp;lt;/text&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;js模块&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;modal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;@weex-module/modal&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;modal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;我是提示框&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其他的还有stream,dom，animation之类的&lt;/p&gt;

&lt;p&gt;事件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;div onviewappear=&quot;viewappear&quot; onviewdisappear=&quot;viewdisappear&quot;&amp;gt;
          ......
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;weex源码结构&quot;&gt;Weex源码结构&lt;/h3&gt;

&lt;p&gt;package.json&lt;/p&gt;

&lt;p&gt;node_modules依赖，更重要的是里面包含了npm run xxx 等快捷命令。比如之前我们运行node.js程序是这样的：$ node xx.js。这里我们可以把它配置化，例如package.json文件中scripts的 “build:config”: “node build/config.frameworks.js”，其实就是npm run build:config 相当于执行了node build/config.frameworks.js&lt;/p&gt;

&lt;p&gt;start文件: 启动程序文件，里面包换编译和启动脚本：&lt;/p&gt;

&lt;p&gt;examples: 示例Demo&lt;/p&gt;

&lt;p&gt;android/ios/html： 各平台代码&lt;/p&gt;

&lt;p&gt;build：打包各平台的脚本，配置在package.json中。&lt;/p&gt;

&lt;p&gt;参考链接:&lt;a href=&quot;https://vczero.github.io/weex-learning/002_modify_example.html&quot;&gt;第2篇 了解Weex源码结构，修改example&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;初始化工程&quot;&gt;初始化工程&lt;/h3&gt;

&lt;p&gt;初始化工程前需要先安装 &lt;a href=&quot;http://brew.sh/index_zh-cn.html&quot;&gt;homebrew&lt;/a&gt;，然后按照下面步骤创建一个工程。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;brew&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;node&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;//通过brew安装node&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;weex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toolkit&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//通过node安装 weex-toolkit  &lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cocoapods&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//安装iOS包管理工具 cocoapods&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;weex&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;//创建项目的文件&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;//依赖安装 package.json文件&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dev&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;//项目编译&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;serve&lt;/span&gt;                 &lt;span class=&quot;c1&quot;&gt;//启动轻量服务器  &lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时有可能提示&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm WARN babel-loader@6.2.5 requires a peer of babel-core@^6.0.0 but none was installed.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你需要再&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install babel-core

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时，打开浏览器，输入http://127.0.0.1:8080, 就会看到这个项目的效果:&lt;/p&gt;

&lt;p&gt;参考链接:&lt;a href=&quot;https://vczero.github.io/weex-learning/003_init_project.html&quot;&gt;第3篇 初始化工程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;npm run dev 干了什么呢？&lt;/p&gt;

&lt;p&gt;先看 package.json 文件&lt;/p&gt;

&lt;pre&gt;
{
  &quot;name&quot;: &quot;demo1&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;dev&quot;: &quot;webpack --watch&quot;,
    &quot;serve&quot;: &quot;serve -p 8080&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;serve&quot;: &quot;^1.4.0&quot;,
    &quot;webpack&quot;: &quot;^1.13.1&quot;,
    &quot;weex-html5&quot;: &quot;0.2.18&quot;,
    &quot;weex-loader&quot;: &quot;^0.1.5&quot;
  }
}

&lt;/pre&gt;

&lt;p&gt;npm run dev实际上相当于 webpack –watch&lt;/p&gt;

&lt;p&gt;webpack实际上是执行了默认的webpack.config.js配置文件&lt;/p&gt;

&lt;p&gt;webpack.config.js 引入webpack和weex-loader，entry属性是表示入口文件，output表示输出文件，默认输出到dist文件夹。&lt;/p&gt;

&lt;pre&gt;
require('webpack')
require('weex-loader')

var path = require('path')

module.exports = {
  entry: {
    main: path.join(__dirname, 'src', 'main.we?entry=true')
  },
  output: {
    path: 'dist',
    filename: '[name].js'
  },
  module: {
    loaders: [
      {
        test: /\.we(\?[^?]+)?$/,
        loaders: ['weex-loader']
      }
    ]
  }
}

&lt;/pre&gt;

&lt;p&gt;不过这个自动产生的webpack.config.js的文件有个坑就是，你添加一个新的we文件，他不会自动build为js文件
可以手动添加&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  entry: {
    main: path.join(__dirname, 'src', 'main.we?entry=true'),
    translate: path.join(__dirname, 'src', 'translate.we?entry=true')
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过推荐的是自己遍历所有的we文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require('webpack')
require('weex-loader')

var path = require('path')
var fs = require('fs');

var entry = {};

function walk(dir, root) {
  var directory = path.join(__dirname, root, dir);
  fs.readdirSync(directory)
    .forEach(function(file) {
      var fullpath = path.join(directory, file);
      var stat = fs.statSync(fullpath);
      var extname = path.extname(fullpath);
      if (stat.isFile() &amp;amp;&amp;amp;
             (extname === '.we')) {
        var name = path.join(root, 'build', dir, path.basename(file, extname));
        entry[name] = fullpath + '?entry=true';
      } else if (stat.isDirectory() &amp;amp;&amp;amp;
                  file !== 'build') {
        var subdir = path.join(dir, file);
        walk(subdir, root);
      }
    });
}
walk('./', 'src');
module.exports = {
  entry: entry,
  output: {
    path: '.',
    filename: '[name].js'
  },
  module: {
    loaders: [
      {
        test: /\.we(\?[^?]+)?$/,
        loaders: ['weex-loader']
      }
    ]
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/hugojing/toolbox-weex/blob/master/webpack.config.js&quot;&gt;hugojing  - webpack.config.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/duqian291902259/weex-demo-dusan/blob/master/webpack.config.js&quot;&gt;duqian291902259 - webpack.config.js&lt;/a&gt;
&lt;a href=&quot;https://vczero.github.io/weex-learning/003_init_project.html&quot;&gt;第3篇 初始化工程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;入口文件index.html&lt;/p&gt;

&lt;p&gt;这里可以参考 &lt;a href=&quot;https://github.com/weexteam/article/issues/10&quot;&gt;Integrate Weex HTML5 to your project&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/MrRaindrop/weex_extend_demo&quot;&gt;weex_extend_demo&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;weex代码结构&quot;&gt;weex代码结构&lt;/h3&gt;

&lt;p&gt;template内必须包含唯一的根节点作为父容器, div就是一个很好的选择，里面则是一些Native Components&lt;/p&gt;

&lt;p&gt;style 支持盒子模型和Flexbox&lt;/p&gt;

&lt;p&gt;weex内置了响应式的支持，页面的宽度是以750来做为标准，自动适配所有手机；&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;子组件&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;子组件&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/template&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/style&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nl&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;computed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;custom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;created&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;script里面包含很多ViewModel Options，&lt;/p&gt;

&lt;p&gt;data
methods
computed
init, created, ready
events&lt;/p&gt;

&lt;p&gt;如果需要在模板里实现更多的逻辑判断,你可以使用’computed property’.&lt;/p&gt;

&lt;p&gt;created是生命周期函数，这个时候模板还没有被渲染，常用来在这里定义数据的更新和获取；&lt;/p&gt;

&lt;p&gt;ready是生命周期函数，这个时候模板被渲染，常用来做一些自己上报等；&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/weex/blob/dev/doc/references/cheatsheet.md&quot;&gt;weex- references - Weex Cheat Sheet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;显然we文件的这些代码是不会被 native app 识别的，我们要想办法让这些代码可运行。所以我们同时做了三件事：&lt;/p&gt;

&lt;p&gt;1.在本地用一个叫做 transformer 的工具把这套代码转成纯 JavaScript 代码&lt;/p&gt;

&lt;p&gt;2.在客户端运行一个 JavaScript 引擎，随时接收 JavaScript 代码&lt;/p&gt;

&lt;p&gt;3.在客户端设计一套 JS Bridge，让 native 代码可以和 JavaScript 引擎相互通信&lt;/p&gt;

&lt;p&gt;所以紧接着第二步，就是用 transformer 对代码进行转换，变成客户端可运行的 JavaScript 代码&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/206848/11239127/f7854634-8e24-11e5-8173-3417c63043a4.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/amfe/article/issues/14&quot;&gt;原图&lt;/a&gt;：本地开发时的 Weex Transformer 工作原理&lt;/p&gt;

&lt;p&gt;在 transformer 中，我们主要的工作就是对 HTML、CSS、JavaScript 代码进行解析和重组。这里我们用到了三个非常重要的库：&lt;/p&gt;

&lt;p&gt;HTML 解析工具：&lt;a href=&quot;https://www.npmjs.com/package/htmlparser&quot;&gt;htmlparser&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CSS 解析工具：&lt;a href=&quot;https://www.npmjs.com/package/cssom&quot;&gt;cssom&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 解析工具：&lt;a href=&quot;https://www.npmjs.com/package/uglify-js&quot;&gt;uglify-js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/amfe/article/issues/15&quot;&gt;对无线电商动态化方案的思考（三） &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/amfe/article/issues/14&quot;&gt;对无线电商动态化方案的思考（二） &lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;weex-的生命周期&quot;&gt;Weex 的生命周期&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;在初始化内部变量，并且添加了事件功能后被触发&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;created&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;完成数据绑定之后，模板编译之前被触发&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;模板已经编译并且生成了 Virtual DOM 之后被触发&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;destroyed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;在页面被销毁时调用&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;init内一般用于初始化一些内部变量，绑定一些自定义事件，这时还没有数据绑定，没有创建vdom，所以不能通过this获取到data和methods，也不能获取vdom的节点&lt;/p&gt;

&lt;p&gt;created 完成了数据绑定 ，但还未开始编译模板，可以通过this获取data和methods，但不能获取vdom的节点&lt;/p&gt;

&lt;p&gt;ready表示渲染完成 ，从子组件往上触发&lt;/p&gt;

&lt;p&gt;destroyed 组件销毁，比如页面跳转，从子组件开始往上触发&lt;/p&gt;

&lt;h3 id=&quot;weex的工作原理&quot;&gt;Weex的工作原理&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://res.infoq.com/articles/introducing-weex/zh/resources/QQ20160428162545.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.infoq.com/articles/introducing-weex/zh/resources/QQ20160428162748.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/206848/11239145/0b0bd8e4-8e25-11e5-86e1-704adcfc6141.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/introducing-weex&quot;&gt;Weex详解：灵活的移动端高性能动态化方案 - 勾股&amp;amp;鬼道&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/amfe/article/issues/14&quot;&gt;对无线电商动态化方案的思考（二）&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;页面间通信&quot;&gt;页面间通信&lt;/h3&gt;

&lt;p&gt;页面跳转是通过指定下一个页面的url，然后通过openurl或者push的方式来跳转&lt;/p&gt;

&lt;p&gt;获取url的方式可以通过下面这段JS代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getAppBaseUrl(self) {
    var dir ='examples'
    var url = self.$getConfig().bundleUrl;
    var bundleUrl = url;
    bundleUrl = new String(bundleUrl);

    var nativeBase;
    var isAndroidAssets = bundleUrl.indexOf('file://assets/') &amp;gt;= 0;

    var isiOSAssets = bundleUrl.indexOf('file:///') &amp;gt;= 0;
    if (isAndroidAssets) {
      nativeBase = 'file://assets/';
    }
    else if (isiOSAssets) {
      nativeBase = bundleUrl.substring(0, bundleUrl.lastIndexOf('/') + 1);
    }
    else {
      var host = 'localhost:12580';
      var matches = /\/\/([^\/]+?)\//.exec(self.$getConfig().bundleUrl);
      if (matches &amp;amp;&amp;amp; matches.length &amp;gt;= 2) {
        host = matches[1];
      }
      nativeBase = 'http://' + host + '/' + dir + '/build/';
    }
    var h5Base = './index.html?page=./' + dir + '/build/';
    //Native端
    var base = nativeBase;
    //H5端
    if (typeof window === 'object') {
      base = h5Base;
    }
    return base
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://vczero.github.io/weex-learning/006_navigation.html&quot;&gt;第六篇 导航、页面跳转、stream、webview&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;页面通信有两种方式&lt;/p&gt;

&lt;p&gt;1.通过 url 参数传递。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 获取URL参数
 */
getUrlParam: function (key) {
    var t = this.$getConfig().bundleUrl;
    var reg = new RegExp('[?|&amp;amp;]' + key + '=([^&amp;amp;]+)');
    var match = t.match(reg);
    return match &amp;amp;&amp;amp; match[1];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.通过 localStorage 数据存储。&lt;/p&gt;

&lt;p&gt;如果是组件间通信不是页面通信，则参考：&lt;a href=&quot;https://github.com/weexteam/article/issues/16&quot;&gt;组件之间通信 - (Communicate Between Components)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;boxmodel--flexbox&quot;&gt;boxmodel &amp;amp; flexbox&lt;/h3&gt;

&lt;p&gt;weex支持boxmodel 和flexbox&lt;/p&gt;

&lt;p&gt;下面这个是boxmodel&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.w3school.com.cn/i/ct_boxmodel.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于flexbox，可以看我的这篇文章[react-native的第一课&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;flexbox布局](http://coderyi.com/posts/react-native_first_lesson/#flexbox布局)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;weex的缺点&quot;&gt;weex的缺点&lt;/h3&gt;

&lt;p&gt;1.Weex将整个app的宽度定死在750px，然后其他都是根据scale进行计算的，会导致适配不方便。&lt;/p&gt;

&lt;p&gt;2.目前不支持iOS的presentViewController方法&lt;/p&gt;

&lt;p&gt;3.很多组件和模块需要自己扩展（比如datepicker，iconfont，摄像头，二维码等）&lt;/p&gt;

&lt;h3 id=&quot;几个小问题&quot;&gt;几个小问题&lt;/h3&gt;

&lt;p&gt;1.之前weex是只支持es5，现在可以支持es6了。&lt;a href=&quot;http://weex.help/topic/578c9649ac4eeead13b2a8f1&quot;&gt;精华 新版weex-loader@0.3.0-alpha，欢迎试用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.怎么断点调试？&lt;/p&gt;

&lt;p&gt;目前是可以断点调试的，可以参考下面文章&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/weexteam/article/issues/50&quot;&gt;Weex调试神器——Weex Devtools使用手册 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/h5weex/h5weex-books/blob/master/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95.md&quot;&gt;线上调试&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.weex支持本地图片吗？&lt;/p&gt;

&lt;p&gt;根据官方答疑是可以的，但是我目前还没有尝试成功。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/weex/blob/doc/doc/faq.md#use-local-image&quot;&gt;faq:use-local-image&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://github.com/Jinjiang/weex-x&quot;&gt;weex-x&lt;/a&gt;的使用？&lt;/p&gt;

&lt;p&gt;5.promise怎么使用？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/weex/issues/1269&quot;&gt;issues - 1269&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6.热更新方案是什么？&lt;/p&gt;

&lt;p&gt;最后，希望有越来越多的人把weex用起来。&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/weex1/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/weex1/</guid>
        
        <category>Weex</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>react-native的第一课</title>
        <description>&lt;p&gt;2016-01-22&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderyi&quot;&gt;coderyi&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#react-用于构建用户界面的javascript库&quot;&gt;React-用于构建用户界面的JavaScript库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#flexbox布局&quot;&gt;Flexbox布局&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#组件的生命周期&quot;&gt;组件的生命周期&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#navigator&quot;&gt;Navigator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#react-native与原生交互&quot;&gt;react-native与原生交互&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#es6与es5&quot;&gt;ES6与ES5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#promise&quot;&gt;Promise&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fetch&quot;&gt;fetch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#npm&quot;&gt;npm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;react-用于构建用户界面的javascript库&quot;&gt;React-用于构建用户界面的JavaScript库&lt;/h3&gt;

&lt;p&gt;React是作为MVC中V存在的，React有一个JSX的编译器，JSX 让你可以用 HTML 语法去写 JavaScript 函数调用。&lt;/p&gt;

&lt;p&gt;举例JSX是以下写法：&lt;/p&gt;

&lt;pre&gt;
&amp;lt;div&amp;gt;
     &amp;lt;MyLabel  text={TextLabel} /&amp;gt;
     &amp;lt;MyTextfield /&amp;gt;
     &amp;lt;MyButton textlabel='OK' /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;如果不经过JSX转化，你就必须用下面JavaScript的写法：&lt;/p&gt;

&lt;pre&gt;
React.createElement(&quot;div&quot;, null, 
     React.createElement(MyLabel, {text: TextLabel}), 
     React.createElement(MyTextfield, null), 
     React.createElement(MyButton, {textlabel: &quot;OK&quot;}))
&lt;/pre&gt;

&lt;p&gt;其实如果是写界面，JSX的XML风格就看起来比JavaScript人性化了。&lt;/p&gt;

&lt;p&gt;React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)，React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。&lt;/p&gt;

&lt;p&gt;React 使用 Virtual DOM 来渲染 UI，当组件状态 state 有更改的时候，React 会自动调用组件的 render 方法重新渲染整个组件的 UI。&lt;/p&gt;

&lt;p&gt;React之所以快，就是因为没有直接操作DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。&lt;/p&gt;

&lt;p&gt;React 操作具体可以看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.ibm.com/developerworks/cn/web/wa-react-intro/figure1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Flux是Facebook用来构建用户端的web应用的应用程序体系架构。它通过利用数据的单向流动为React的可复用的视图组件提供了补充。Flux应用主要包括三部分：dispatcher、store和views（React components）,dispatcher处理动作分发，维护Store之间的依赖关系，store是数据和逻辑部分，views是React组件，这一层可以看作controller-views,作为视图同时响应用户交互，最后其实还有一个action部分，提供dispatcher传递数据给store&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://facebook.github.io/flux/img/flux-simple-f8-diagram-explained-1300w.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://reactjs.cn/react/index.html&quot;&gt;React-中文文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/wa-react-intro/&quot;&gt;React：创建可维护、高性能的 UI 组件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/react-tutorial/&quot;&gt;极客学院-React 入门教程&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;flexbox布局&quot;&gt;Flexbox布局&lt;/h3&gt;

&lt;p&gt;Flex布局主要思想是让容器有能力让其子项目能够改变其宽度、高度(甚至顺序)，以最佳方式填充可用空间（主要是为了适应所有类型的显示设备和屏幕大小）。&lt;/p&gt;

&lt;p&gt;基本上，伸缩项目是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）或者沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列。&lt;/p&gt;

&lt;p&gt;这里可以看一下flexbox的几个主要属性&lt;/p&gt;

&lt;p&gt;flex-direction（适用于伸缩容器，也就是伸缩项目的父元素）&lt;/p&gt;

&lt;p&gt;这个主要用来创建主轴，从而定义了伸缩项目放置在伸缩容器的方向。&lt;/p&gt;

&lt;pre&gt;
flex-direction: row | row-reverse | column | column-reverse	

&lt;/pre&gt;

&lt;p&gt;flex-wrap(适用于伸缩容器)
这个主要用来定义伸缩容器里是单行还是多行显示，侧轴的方向决定了新行堆放的方向。&lt;/p&gt;

&lt;pre&gt;
flex-wrap: nowrap | wrap | wrap-reverse	

&lt;/pre&gt;

&lt;p&gt;justify-content（适用于伸缩容器）&lt;/p&gt;

&lt;p&gt;这个是用来定义伸缩项目沿着主轴线的对齐方式。当一行上的所有伸缩项目都不能伸缩或可伸缩但是已经达到其最大长度时，这一属性才会对多余的空间进行分配。&lt;/p&gt;

&lt;pre&gt;
justify-content: flex-start | flex-end | center | space-between | space-around	

&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.css-tricks.com/wp-content/uploads/2013/04/justify-content.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;align-item（适用于伸缩容器）&lt;/p&gt;

&lt;p&gt;这个主要用来定义伸缩项目可以在伸缩容器的当前行的侧轴上对齐方式。可以把他想像成侧轴（垂直于主轴）的“justify-content”。&lt;/p&gt;
&lt;pre&gt;
align-items: flex-start | flex-end | center | baseline | stretch	

&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;align-content(适用于伸缩容器)&lt;/p&gt;

&lt;p&gt;这个属性主要是伸缩容器多行是主轴的对齐方式&lt;/p&gt;
&lt;pre&gt;
align-content: flex-start | flex-end | center | space-between | space-around | stretch	

&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/css3/a-guide-to-flexbox.html&quot;&gt;一个完整的Flexbox指南&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;组件的生命周期&quot;&gt;组件的生命周期&lt;/h3&gt;

&lt;p&gt;React组件的生命周期如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7rf9ir.com1.z0.glb.clouddn.com/3-3-component-lifecycle.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以组件生命周期就是有三个阶段：&lt;/p&gt;

&lt;p&gt;实例化：当首次使用组件类时&lt;/p&gt;

&lt;p&gt;存在期：当实例已经生成，修改属性时&lt;/p&gt;

&lt;p&gt;销毁期：当组件卸载消亡时&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.race604.com/react-native-component-lifecycle/&quot;&gt;React Native 中组件的生命周期&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;navigator&quot;&gt;Navigator&lt;/h3&gt;

&lt;p&gt;Navigator和NavigatorIOS都可以用来管理应用中“场景”的导航（也可以称作屏幕）。导航器建立了一个路由栈，用来弹出，推入或者替换路由状态。主要的区别在于NavigatorIOS使用了iOS中的UINavigationController类，而Navigator则完全用js重写了一个类似功能的React组件。&lt;/p&gt;

&lt;p&gt;关于Navigator，可以看一下下面的示例：&lt;/p&gt;
&lt;pre&gt;
// index.ios.js

var {
    View,
    Navigator
} = React;
var FirstPageComponent = require('./FirstPageComponent');

var SampleComponent = React.createClass({
    render: function() {
        var defaultName = 'FirstPageComponent';
        var defaultComponent = FirstPageComponent;
        return (
        &amp;lt;Navigator
          initialRoute={ { name: defaultName, component: defaultComponent } }
          configureScene={() =&amp;gt; {
            return Navigator.SceneConfigs.VerticalDownSwipeJump;
          }}
          renderScene={(route, navigator) =&amp;gt; {
            let Component = route.component;
            if(route.component) {
              return &amp;lt;Component {...route.params} navigator={navigator} /&amp;gt;
            }
          }} /&amp;gt;
        );

    }
});
&lt;/pre&gt;

&lt;p&gt;initialRoute={ { name: defaultName, component: defaultComponent } } 这个指定了默认的页面，也就是启动app之后会看到界面的第一屏。 需要填写两个参数: name 跟 component。&lt;/p&gt;

&lt;p&gt;configureScene 这个是页面之间跳转时候的动画，具体有哪些？可以看这个目录下，有源代码的: node_modules/react-native/Libraries/CustomComponents/Navigator/NavigatorSceneConfigs.js&lt;/p&gt;

&lt;p&gt;renderScene,我们先看到回调里的两个参数:route, navigator。route里其实就是我们传递的name,component。navigator是一个Navigator的对象，这里是返回route.component组件，然后navigator作为props传递给了这个component，我们可以在FirstPageComponent里面通过props.navigator拿到。&lt;/p&gt;

&lt;pre&gt;
//FirstPageComponent.js
var {
    View,
    Text,
    TouchableOpacity
} = React;

var SecondPageComponent = require('./SecondPageComponent');

var FirstPageComponent = React.create({
    getInitialState: function() {
        return {
            id: 2,
        };
    },

    componentDidMount: function() {
    },

    _pressButton: function() {
        const { navigator } = this.props;
        if(navigator) {
            navigator.push({
                name: 'SecondPageComponent',
                component: SecondPageComponent,
                //这里多出了一个 params 其实来自于Navigator 里的一个方法的参数...
                params: {
                    id: this.state.id
                }
            });
        }
    },

    render: function() {
        return (
            &amp;lt;View&amp;gt;
                &amp;lt;TouchableOpacity onPress={this._pressButton}&amp;gt;
                    &amp;lt;Text&amp;gt;点我跳转并传递id&amp;lt;/Text&amp;gt;
                &amp;lt;/TouchableOpacity&amp;gt;
            &amp;lt;/View&amp;gt;
        );
    }
});

&lt;/pre&gt;

&lt;p&gt;在index.ios.js里面有&lt;/p&gt;
&lt;pre&gt;
            return &amp;lt;Component {...route.params} navigator={navigator} /&amp;gt;

&lt;/pre&gt;
&lt;p&gt;“…“就是把route.params每个key作为props的一个属性，所以在FirstPageComponent.js设置的params值，将在它push到的页面接收到。&lt;/p&gt;

&lt;pre&gt;
//SecondPageComponent.js
var {
    View,
    Text,
    TouchableOpacity,
} = React;

var FirstPageComponent = require('./FirstPageComponent');

var SecondPageComponent = React.create({
    getInitialState: function() {
        return {
            id: null
        };
    },
    componentDidMount: function() {
        //这里获取从FirstPageComponent传递过来的参数: id
        this.setState({
            id: this.props.id
        });
    },
    _pressButton: function() {
        const { navigator } = this.props;
        if(navigator) {
            navigator.pop();
        }
    },
    render: function() {
        return (
            &amp;lt;View&amp;gt;
                &amp;lt;Text&amp;gt;获得的参数: id={ this.state.id }&amp;lt;/Text&amp;gt;
                &amp;lt;TouchableOpacity onPress={this._pressButton}&amp;gt;
                    &amp;lt;Text&amp;gt;点我跳回去&amp;lt;/Text&amp;gt;
                &amp;lt;/TouchableOpacity&amp;gt;
            &amp;lt;/View&amp;gt;
        );
    }
});
&lt;/pre&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bbs.reactnative.cn/topic/20/%E6%96%B0%E6%89%8B%E7%90%86%E8%A7%A3navigator%E7%9A%84%E6%95%99%E7%A8%8B&quot;&gt;新手理解Navigator的教程&lt;/a&gt; 对于Navigator讲解的特别详细&lt;/p&gt;

&lt;h3 id=&quot;react-native与原生交互&quot;&gt;react-native与原生交互&lt;/h3&gt;
&lt;p&gt;在React Native中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类，其中RCT是ReaCT的缩写。&lt;/p&gt;

&lt;p&gt;为了实现RCTBridgeModule协议，你的类需要包含RCT_EXPORT_MODULE()宏。这个宏也可以添加一个参数用来指定在Javascript中访问这个模块的名字。如果你不指定，默认就会使用这个Objective-C类的名字。&lt;/p&gt;

&lt;p&gt;JS可以调用Native的方法，
Native代码：&lt;/p&gt;
&lt;pre&gt;
RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location (RCTResponseSenderBlock)callback)
{
  RCTLogInfo(@&quot;Pretending to create an event %@ at %@&quot;, name, location);
  NSArray *events = ...
  callback(@[[NSNull null], events]);
}

&lt;/pre&gt;

&lt;p&gt;JS调用如下&lt;/p&gt;
&lt;pre&gt;
var CalendarManager = require('react-native').NativeModules.CalendarManager;
CalendarManager.addEvent('Birthday Party', '4 Privet Drive, Surrey',(error,events) =&amp;gt; {
        if (error) {
            alert(error)
        }else{
           alert(events)
        };
});
&lt;/pre&gt;

&lt;p&gt;当然Native也可以调用JS
native调用&lt;/p&gt;
&lt;pre&gt;
#import &quot;RCTBridge.h&quot;
#import &quot;RCTEventDispatcher.h&quot;

@implementation CalendarManager

@synthesize bridge = _bridge;

- (void)calendarEventReminderReceived:(NSNotification *)notification
{
  NSString *eventName = notification.userInfo[@&quot;name&quot;];
  [self.bridge.eventDispatcher sendAppEventWithName:@&quot;EventReminder&quot;
                                               body:@{@&quot;name&quot;: eventName}];
}

@end
&lt;/pre&gt;

&lt;p&gt;在JS中订阅该事件&lt;/p&gt;
&lt;pre&gt;
var { NativeAppEventEmitter } = require('react-native');

var subscription = NativeAppEventEmitter.addListener(
  'EventReminder',
  (reminder) =&amp;gt; console.log(reminder.name)
);
...
// 千万不要忘记忘记取消订阅, 通常在componentWillUnmount函数中实现。
subscription.remove();
&lt;/pre&gt;

&lt;p&gt;基于上面的规则，react-native对很多原生模块进行了封装，比如UIView，他们实现RCTViewManager类，RCTViewManager实现了协议RCTBridgeModule，这样JS就可以使用native组件了。&lt;/p&gt;

&lt;p&gt;默认的情况下，react-native只注册一个RCTRootView，&lt;/p&gt;
&lt;pre&gt;
RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                                      moduleName:@&quot;CommunicateNativeDemo&quot;
                                               initialProperties:nil
                                                   launchOptions:launchOptions];

  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
  UIViewController *rootViewController = [UIViewController new];
  rootViewController.view = rootView;
  self.window.rootViewController = rootViewController;
  [self.window makeKeyAndVisible];
&lt;/pre&gt;

&lt;pre&gt;
AppRegistry.registerComponent('CommunicateNativeDemo', () =&amp;gt; CommunicateNativeDemo);

&lt;/pre&gt;

&lt;p&gt;上面代码中注册的RCTRootView就是整个程序的入口，当然如果你有多个入口或者其他方面的需求，也可以注册多个，不native的不同地方使用JS模块。&lt;/p&gt;
&lt;pre&gt;
AppRegistry.registerComponent('FirstView', () =&amp;gt; CommunicateNativeDemo);
AppRegistry.registerComponent('SecondView', () =&amp;gt; CommunicateNativeDemo);
AppRegistry.registerComponent('ThirdView', () =&amp;gt; CommunicateNativeDemo);

&lt;/pre&gt;

&lt;p&gt;然后把这三个组件通过RCTRootView加载到原生上&lt;/p&gt;
&lt;pre&gt;
- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.title = @&quot;First View&quot;;
    AppDelegate *delegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];
    RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:delegate.bridge moduleName:@&quot;FirstView&quot;];
    rootView.frame = CGRectMake(20, 84, [UIScreen mainScreen].bounds.size.width - 40, 200);
    [self.view addSubview:rootView];
}
&lt;/pre&gt;

&lt;p&gt;react-native中Obj-C和JavaScript通信原理简单说一下，和我们经常用的bridge差不多，Obj-C调用JavaScript很简单，可以通过webview的stringByEvaluatingJavaScriptFromString:方法调用JavaScript代码；JavaScript调用Obj-C，则是通过web view的代理方法shouldStartLoadWithRequest：来接收JavaScript的网络请求从而实现调用。&lt;/p&gt;

&lt;h3 id=&quot;es6与es5&quot;&gt;ES6与ES5&lt;/h3&gt;

&lt;p&gt;ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。ECMAScript 5和ECMAScript 6分别是2009年和2015年发布的，下面列出一些主要的ES6与ES5的不同写法。&lt;/p&gt;

&lt;h6 id=&quot;引用&quot;&gt;引用&lt;/h6&gt;

&lt;p&gt;在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样：&lt;/p&gt;

&lt;pre&gt;
//ES5
var React = require(&quot;react-native&quot;);
var {
    Image,
    Text,
    PropTypes
} = React;  //引用不同的React Native组件
&lt;/pre&gt;

&lt;p&gt;在ES6里，import写法更为标准&lt;/p&gt;

&lt;pre&gt;
//ES6
import React, {
    Image, 
    Text,
    PropTypes
} from 'react-native';
&lt;/pre&gt;

&lt;h6 id=&quot;导出单个类&quot;&gt;导出单个类&lt;/h6&gt;

&lt;p&gt;在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出&lt;/p&gt;
&lt;pre&gt;
//ES5
var MyComponent = React.createClass({
    ...
});
module.exports = MyComponent;

&lt;/pre&gt;
&lt;p&gt;在ES6里，通常用export default来实现相同的功能：&lt;/p&gt;
&lt;pre&gt;
//ES6
export default class MyComponent extends React.Component{
    ...
}
&lt;/pre&gt;

&lt;h6 id=&quot;给组件定义方法&quot;&gt;给组件定义方法&lt;/h6&gt;

&lt;p&gt;给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。&lt;/p&gt;
&lt;pre&gt;
//ES5 
var Photo = React.createClass({
    componentWillMount: function(){

    },
    render: function() {
        return (
            &amp;lt;Image source={this.props.source} /&amp;gt;
        );
    },
});
&lt;/pre&gt;
&lt;pre&gt;
//ES6
class Photo extends React.Component {
    componentWillMount() {

    }
    render() {
        return (
            &amp;lt;Image source={this.props.source} /&amp;gt;
        );
    }
}
&lt;/pre&gt;

&lt;h6 id=&quot;定义组件的属性类型和默认属性&quot;&gt;定义组件的属性类型和默认属性&lt;/h6&gt;

&lt;p&gt;在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现&lt;/p&gt;
&lt;pre&gt;
//ES5 
var Video = React.createClass({
    getDefaultProps: function() {
        return {
            autoPlay: false,
            maxLoops: 10,
        };
    },
    propTypes: {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    },
    render: function() {
        return (
            &amp;lt;View /&amp;gt;
        );
    },
});

&lt;/pre&gt;
&lt;p&gt;在ES6里，可以统一使用static成员来实现&lt;/p&gt;
&lt;pre&gt;
//ES6
class Video extends React.Component {
    static defaultProps = {
        autoPlay: false,
        maxLoops: 10,
    };  // 注意这里有分号
    static propTypes = {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    };  // 注意这里有分号
    render() {
        return (
            &amp;lt;View /&amp;gt;
        );
    } // 注意这里既没有分号也没有逗号
}
&lt;/pre&gt;

&lt;h6 id=&quot;初始化state&quot;&gt;初始化state&lt;/h6&gt;

&lt;pre&gt;
//ES5 
var Video = React.createClass({
    getInitialState: function() {
        return {
            loopsRemaining: this.props.maxLoops,
        };
    },
})
&lt;/pre&gt;
&lt;p&gt;ES6下，有两种写法：&lt;/p&gt;

&lt;pre&gt;
//ES6
class Video extends React.Component {
    state = {
        loopsRemaining: this.props.maxLoops,
    }
}
&lt;/pre&gt;
&lt;p&gt;不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）：&lt;/p&gt;

&lt;pre&gt;
//ES6
class Video extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            loopsRemaining: this.props.maxLoops,
        };
    }
}
&lt;/pre&gt;

&lt;h6 id=&quot;把方法作为回调提供&quot;&gt;把方法作为回调提供&lt;/h6&gt;

&lt;p&gt;在JS中，this指的是，调用函数的那个对象。在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。&lt;/p&gt;
&lt;pre&gt;
//ES5
var PostInfo = React.createClass({
    handleOptionsButtonClick: function(e) {
        // Here, 'this' refers to the component instance.
        this.setState({showOptionsModal: true});
    },
    render: function(){
        return (
            &amp;lt;TouchableHighlight onPress={this.handleOptionsButtonClick}&amp;gt;
                &amp;lt;Text&amp;gt;{this.props.label}&amp;lt;/Text&amp;gt;
            &amp;lt;/TouchableHighlight&amp;gt;
        )
    },
});

&lt;/pre&gt;

&lt;p&gt;在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用&lt;/p&gt;

&lt;pre&gt;
//ES6
class PostInfo extends React.Component
{
    handleOptionsButtonClick(e){
        this.setState({showOptionsModal: true});
    }
    render(){
        return (
            &amp;lt;TouchableHighlight 
                onPress={this.handleOptionsButtonClick.bind(this)}
                onPress={e=&amp;gt;this.handleOptionsButtonClick(e)}
                &amp;gt;
                &amp;lt;Text&amp;gt;{this.props.label}&amp;lt;/Text&amp;gt;
            &amp;lt;/TouchableHighlight&amp;gt;
        )
    },
}
&lt;/pre&gt;

&lt;p&gt;需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用&lt;/p&gt;

&lt;pre&gt;
// 错误的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener('change', this.onAppPaused.bind(this));
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener('change', this.onAppPaused.bind(this));
    }
    onAppPaused(event){
    }
}

&lt;/pre&gt;
&lt;pre&gt;
// 正确的做法
class PauseMenu extends React.Component{
    constructor(props){
        super(props);
        this._onAppPaused = this.onAppPaused.bind(this);
    }
    componentWillMount(){
        AppStateIOS.addEventListener('change', this._onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener('change', this._onAppPaused);
    }
    onAppPaused(event){
    }
}
&lt;/pre&gt;
&lt;p&gt;当然你也可以这样做&lt;/p&gt;
&lt;pre&gt;
// 正确的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener('change', this.onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener('change', this.onAppPaused);
    }
    onAppPaused = (event) =&amp;gt; {
        //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针
    }
}
&lt;/pre&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8&quot;&gt;React/React Native 的ES5 ES6写法对照表
&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;promise&quot;&gt;Promise&lt;/h3&gt;

&lt;p&gt;其实已经有一些第三方库实现了 Promise 的功能：Q、when、WinJS、RSVP.js，这些库和 JavaScript 原生 Promise 都遵守一个通用的、标准化的规范：CommonJS组织制定的异步模式编程规范Promises/A+，jQuery 有个类似的方法叫 Deferred，但不兼容 Promises/A+ 规范，于是会有点小问题，使用需谨慎。jQuery 还有一个 Promise 类型，它其实是 Deferred 的缩减版，所以也有同样问题。&lt;/p&gt;

&lt;p&gt;JavaScript是从ES6提供Promise对象的，这里简单讲一下原生的Promise。&lt;/p&gt;

&lt;p&gt;Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。&lt;/p&gt;

&lt;pre&gt;
var promise = new Promise(function(resolve, reject) {
 if (/* 异步操作成功 */){
 resolve(value);
 } else {
 reject(error);
 }
});

promise.then(function(value) {
 // success
}, function(value) {
 // failure
});
&lt;/pre&gt;

&lt;p&gt;Promise很好的解决了异步调用的问题，但是ES7 中有了更加标准的解决方案，新增了 async/await 两个关键词。async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。&lt;/p&gt;

&lt;p&gt;async/await 究竟是怎么解决异步调用的写法呢？简单来说，就是将异步操作用同步的写法来写。先来看下最基本的语法（ES7 代码片段）：&lt;/p&gt;
&lt;pre&gt;
const f = () =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve(123);
    }, 2000);
  });
};

const testAsync = async () =&amp;gt; {
  const t = await f();
  console.log(t);
};

testAsync();
&lt;/pre&gt;

&lt;p&gt;对比 Promise&lt;/p&gt;

&lt;pre&gt;
const f = () =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve(123);
    }, 2000);
  });
};

const testAsync = () =&amp;gt; {
  f().then((t) =&amp;gt; {
    console.log(t);
  });
};

testAsync();
&lt;/pre&gt;

&lt;p&gt;关于异步编程，JS里面还另一种访问就是RxJS，Reactive Programming，RP是什么，RP是针对异步数据流的编程，一定程度而言，RP并不算新的概念。Event Bus、点击事件都是异步流。Rx最近比较流行，下次有时间再看吧！&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/es6/promises/&quot;&gt;JavaScript Promises&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/063f7e490e9a&quot;&gt;Javascript 中的神器——Promise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000002566697&quot;&gt;JavaScript ES7 中使用 async/await 解决回调函数嵌套问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.leancloud.cn/3910/?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;「大概可能也许是」目前最好的 JavaScript 异步方案 async/await&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004293922&quot;&gt;RxJS 教程&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;fetch&quot;&gt;fetch&lt;/h3&gt;

&lt;p&gt;JavaScript很长时间通过XMLHttpRequest来执行异步网络请求，XMLHttpRequest是基于事件的。&lt;a href=&quot;https://github.com/github/fetch&quot;&gt;fetch&lt;/a&gt;则是通过Promise来实现的，fetch的返回值是一个Promise对象&lt;/p&gt;

&lt;pre&gt;
fetch('https://mywebsite.com/endpoint/', {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    firstParam: 'yourValue',
    secondParam: 'yourOtherValue',
  })
})
&lt;/pre&gt;

&lt;p&gt;如果要异步操作的话&lt;/p&gt;
&lt;pre&gt;
fetch('https://mywebsite.com/endpoint.php')
  .then((response) =&amp;gt; response.text())
  .then((responseText) =&amp;gt; {
    console.log(responseText);
  })
  .catch((error) =&amp;gt; {
    console.warn(error);
  });
&lt;/pre&gt;

&lt;p&gt;使用ES7的async/await语法来发起一个异步调用&lt;/p&gt;
&lt;pre&gt;
async getUsersFromApi() {
  try {
    let response = await fetch('https://mywebsite.com/endpoint/');
    return response.users;
  } catch(error) {
    throw error;
  }
}
&lt;/pre&gt;

&lt;p&gt;ES6中还有生成器（Generator），promise 和生成器（Generator）为开发者进行异步编程带来了极大便利。&lt;/p&gt;

&lt;p&gt;生成器函数其实是基于迭代器实现的，并且有如下的结构：&lt;/p&gt;
&lt;pre&gt;
function *myIterator() {
    while(condition) {
        yield value;    
    }   
}
&lt;/pre&gt;

&lt;p&gt;yield关键字负责返回结果，它会暂停迭代器函数的执行直到它被再一次的调用。它也会记住函数的状态， 而不是在下次执行的时候重新运行一切，它能够有效的记住上一次暂停的地方。&lt;/p&gt;

&lt;p&gt;将Fetch API和生成器组合起来使用的一个场景是长轮询。 长轮询是一种通过客户端不断发送请求给服务器直到获得响应的技术。生成器可以用于这样的场景来不断的yielding响应直到响应包含数据。&lt;/p&gt;

&lt;p&gt;现在让我们编写生成器函数来不断的调用这个API，每次迭代会返回一个Promise对象。&lt;/p&gt;
&lt;pre&gt;
    function *pollForWeatherInfo() {
        while(true) {
            yield fetch('/api/currentWeather', {
                method: 'get'   
            }).then(d =&amp;gt; d.json()); 
        }   
    }
&lt;/pre&gt;

&lt;p&gt;我们需要一个函数来不断的调用这个函数，并且检查每次返回的Promise是否存在天气信息。 可以使用一个在下一次迭代时调用的递归函数来实现，并且只在发现了从服务器返回的值的时候才暂停这一过程。 下面的代码展示了上述过程的实现&lt;/p&gt;
&lt;pre&gt;
function runPolling(generator){
    if(!generator){
        generator = pollForWeatherInfo();
    }

    var p = generator.next();
    p.value.then(function(d){
        if(!d.temperature){
            runPolling(generator);
        } else {
            console.log(d);
        }
    });
}

runPolling();
&lt;/pre&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/sravikiran/FetchAPI-Generators&quot;&gt;示例代码源码-FetchAPI-Generators&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wwsun.github.io/posts/async-api-using-fetch-and-generators.html&quot;&gt;使用Fetch API和ES6生成器来构建异步API&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;npm&quot;&gt;npm&lt;/h3&gt;

&lt;p&gt;react-native开发环境需要使用node.js,npm是Node.js默认的模块管理器，是一个命令行下的软件，用来安装和管理node模块。&lt;/p&gt;

&lt;p&gt;Node模块采用npm install命令安装。每个模块可以“全局安装”，也可以“本地安装”。两者的差异是模块的安装位置，以及调用方法。&lt;/p&gt;

&lt;p&gt;“全局安装”指的是将一个模块直接下载到Node的安装目录中，各个项目都可以调用。“本地安装”指的是将一个模块下载到当前目录的node_modules子目录，然后只有在当前目录和它的子目录之中，才能调用这个模块。一般来说，全局安装只适用于工具模块，比如npm和grunt。&lt;/p&gt;

&lt;p&gt;默认情况下，npm install命令是“本地安装”某个模块。&lt;/p&gt;

&lt;pre&gt;
$ npm install [package name]
$ npm install git://github.com/package/path.git
$ npm install git://github.com/package/path.git#0.1.0
$ npm install sax@latest
$ npm install sax@0.1.1
$ npm install sax@&quot;&amp;gt;=0.1.0 &amp;lt;0.2.0&quot;
&lt;/pre&gt;

&lt;p&gt;使用global参数，可以“全局安装”某个模块。global参数可以被简化成g参数。&lt;/p&gt;

&lt;pre&gt;
$ sudo npm install -global [package name]
$ sudo npm install -g [package name]
&lt;/pre&gt;

&lt;p&gt;–save：模块名将被添加到packages.json文件的dependencies，可以简化为参数-S。
–save-dev: 模块名将被添加到packages.json文件的devDependencies，可以简化为参数-D。&lt;/p&gt;

&lt;pre&gt;
$ npm install sax --save
$ npm install node-tap --save-dev
 或者
$ npm install sax -S
$ npm install node-tap -D
&lt;/pre&gt;

&lt;p&gt;npm install默认会安装dependencies字段和devDependencies字段中的所有模块，如果使用production参数，可以只安装dependencies字段的模块。&lt;/p&gt;

&lt;pre&gt;
$ npm install --production

&lt;/pre&gt;

&lt;p&gt;dependencies是项目中依赖的模块，如果你想要开发自己的npm模块，如果有人要使用，那么他们可能不需要你开发使用的外部测试或者文档框架。在这种情况下，最好将这些附属的项目列在devDependencies中。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://javascript.ruanyifeng.com/nodejs/npm.html&quot;&gt;npm模块管理器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ericdum/mujiang.info/issues/6&quot;&gt;npm的package.json中文文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://js.coach/react-native/&quot;&gt;react-native组件库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;转载请注原文链接:https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md&lt;/p&gt;

</description>
        <pubDate>Fri, 22 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/react-native_first_lesson/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/react-native_first_lesson/</guid>
        
        <category>跨平台</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>Objective-C代码注入－拦截NSURLConnection的消息</title>
        <description>&lt;p&gt;2015.11.11&lt;/p&gt;

&lt;h5 id=&quot;混淆一个方法&quot;&gt;混淆一个方法&lt;/h5&gt;

&lt;pre&gt;
    Class class = objc_getMetaClass(class_getName([NSURLConnection class]));
    SEL originalSelector = @selector(sendAsynchronousRequest:queue:completionHandler:);
    SEL swizzledSelector =NSSelectorFromString([NSString stringWithFormat:@&quot;_coderyi_swizzle_%x_%@&quot;, arc4random(), NSStringFromSelector(selector)]);
&lt;/pre&gt;
&lt;p&gt;其实在ObjC中class有两种，一个是对象，一个是类，[NSURLConnection class]或者objc_getClass获取到的是objc_object，而objc_getMetaClass获取到的是objc_class，这里因为sendAsynchronousRequest:queue:completionHandler:是类方法，所有需要使用objc_getMetaClass。objc_class可以通过objc_object的isa.cls获得。&lt;/p&gt;

&lt;h5 id=&quot;消息和方法的动态绑定&quot;&gt;消息和方法的动态绑定&lt;/h5&gt;

&lt;pre&gt;
        typedef void (^NSURLConnectionAsyncCompletion)(NSURLResponse* response, NSData* data, NSError* connectionError);
        
        void (^asyncSwizzleBlock)(Class, NSURLRequest *, NSOperationQueue *, NSURLConnectionAsyncCompletion) = ^(Class slf, NSURLRequest *request, NSOperationQueue *queue, NSURLConnectionAsyncCompletion completion) {
                NSLog(@&quot;i get the request url:  %@&quot;,request.URL);
 
                ((void(*)(id, SEL, id, id, id))objc_msgSend)(slf, swizzledSelector, request, queue, completion);

        };
        
        
    Method originalMethod = class_getInstanceMethod(class, originalSelector);
    if (!originalMethod) {
        return;
    }
    
    IMP implementation = imp_implementationWithBlock(asyncSwizzleBlock);
    class_addMethod(class, swizzledSelector, implementation, method_getTypeEncoding(originalMethod));
    Method newMethod = class_getInstanceMethod(class, swizzledSelector);
    method_exchangeImplementations(originalMethod, newMethod);
&lt;/pre&gt;

&lt;p&gt;这里主要是把自己的消息增加到NSURLConnection类中，并且这条消息会经过asyncSwizzleBlock,block会实现这个方法，这样就能够拦截sendAsynchronousRequest:queue:completionHandler:消息的内容，包括请求的URL等。&lt;/p&gt;

&lt;p&gt;imp_implementationWithBlock的作用是方法被调用的时候，创建一个函数指针，这样就会调用这个block了，在block里面你可以知道这个消息的细节，并且你必须需要自己发送这个消息，你可以通过objc_msgSend函数完成。&lt;/p&gt;

&lt;p&gt;objc_msgSend的函数具体是这样的，你需要把方法的返回值，以及每一个参数加上。&lt;/p&gt;
&lt;pre&gt;
id objc_msgSend(id self, SEL op, arg1, arg2, ...)
&lt;/pre&gt;

&lt;p&gt;关于swizzledSelector你首先需要通过class_addMethod加入到class的方法里面，然后再把刚刚加入的混淆方法，替换掉旧的方法，你可以通过method_exchangeImplementations函数实现。&lt;/p&gt;

&lt;p&gt;注意class_addMethod将会覆盖父类的方法，但不会取代本类的方法，如果需要取代本类，可以用method_setImplementation等函数实现，这里就用method_exchangeImplementations。&lt;/p&gt;

&lt;h5 id=&quot;获取哪些类实现了delegate&quot;&gt;获取哪些类实现了delegate&lt;/h5&gt;

&lt;pre&gt;
        const SEL selectors[] = {
            @selector(connection:willSendRequest:redirectResponse:),
            @selector(connection:didReceiveResponse:),
        };
        
        const int numSelectors = sizeof(selectors) / sizeof(SEL);
        
        Class *classes = NULL;
        int numClasses = objc_getClassList(NULL, 0);
        
        if (numClasses &amp;gt; 0) {
            classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);
            numClasses = objc_getClassList(classes, numClasses);//获取项目中所有的类
            for (NSInteger classIndex = 0; classIndex &amp;lt; numClasses; ++classIndex) {
                Class class = classes[classIndex];
                
                if (class == [NetworkObserver class]) {
                    continue;
                }
                
                unsigned int methodCount = 0;
                Method *methods = class_copyMethodList(class, &amp;amp;methodCount);
                BOOL matchingSelectorFound = NO;
                for (unsigned int methodIndex = 0; methodIndex &amp;lt; methodCount; methodIndex++) {
                    for (int selectorIndex = 0; selectorIndex &amp;lt; numSelectors; ++selectorIndex) {
                        if (method_getName(methods[methodIndex]) == selectors[selectorIndex]) {
                            [self injectWillSendRequestIntoDelegateClass:class];
                            [self injectDidReceiveResponseIntoDelegateClass:class];
                            matchingSelectorFound = YES;
                            break;
                        }
                    }
                    if (matchingSelectorFound) {
                        break;
                    }
                }
                free(methods);
            }
            
            free(classes);
        }
&lt;/pre&gt;

&lt;p&gt;这里的作用是扫描项目中有哪些类实现了NSURLConnectionDataDelegate的connection:willSendRequest:redirectResponse:和connection:didReceiveResponse:方法，objc_getClassList函数就是获取项目中所有的类，扫描每一个类，当得到一个类之后你可以通过class_copyMethodList函数获取到所有的方法，然后你就可以对相应的类注入自己的方法了。&lt;/p&gt;

&lt;h5 id=&quot;动态绑定delegate的消息&quot;&gt;动态绑定delegate的消息&lt;/h5&gt;

&lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;willSendRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redirectResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swizzledSelector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SwizzleUtility&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;swizzledSelectorForSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;Protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSURLConnectionDataDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSURLConnectionDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objc_method_description&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodDescription&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol_getMethodDescription&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLConnectionWillSendRequestBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLConnectionDelegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLConnection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLResponse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;NSURLConnectionWillSendRequestBlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;undefinedBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLConnectionDelegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLConnection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLResponse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NetworkObserver&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sharedObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;willSendRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redirectResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;NSURLConnectionWillSendRequestBlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementationBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLConnectionDelegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLConnection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLResponse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returnValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;undefinedBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;returnValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swizzledSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;


        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;IMP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imp_implementationWithBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;instancesRespondToSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementationBlock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;undefinedBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;class_addMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swizzledSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodDescription&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swizzledSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;method_exchangeImplementations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;class_addMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodDescription&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为class_addMethod时候需要关于方法的描述，所以需要NSURLConnectionDataDelegate中connection:willSendRequest:redirectResponse:的方法描述，可以通过函数protocol_getMethodDescription获得，关方法的实现block需要判断类(这里是ViewController实现了delegate)是否实现该方法，如果没有实现则到此为止，如果有实现connection:willSendRequest:redirectResponse:方法则需要在拦截到消息之后再把消息发送出去。&lt;/p&gt;

&lt;p&gt;以上代码，来自我写的一个Demo,&lt;a href=&quot;https://github.com/coderyi/iOSDemos/tree/master/ObjCInjectCodeDemo&quot;&gt;ObjCInjectCodeDemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我演示的是拦截网络请求，当然你如果需要这方面的功能，可以看看我写的网路调试库,&lt;a href=&quot;https://github.com/coderyi/NetworkEye&quot;&gt;NetworkEye&lt;/a&gt;，NetworkEye用的是NSURLProtocol，并不是这个。&lt;/p&gt;

&lt;h4 id=&quot;参考链接&quot;&gt;参考链接&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/&quot;&gt;Apple Objective-C Runtime Reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot;&gt;apple runtime source code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html&quot;&gt;Objective-C Runtime Programming Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wenku.baidu.com/view/1e06c9a20029bd64783e2cd1.htm&quot;&gt;Objective-C Runtime Programming Guide 中文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/&quot;&gt;Objective-C Runtime 运行时之一：类与对象&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;转载请附本文链接&lt;a href=&quot;https://github.com/coderyi/blog/blob/master/articles/2015/1111_objective-c_inject_code.md&quot;&gt;https://github.com/coderyi/blog/blob/master/articles/2015/1111_objective-c_inject_code.md&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 11 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/objective-c_inject_code/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/objective-c_inject_code/</guid>
        
        <category>Objective-C</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>ffmpeg在iOS的使用-iFrameExtractor源码解析</title>
        <description>&lt;p&gt;iFrameExtractor地址:&lt;a href=&quot;https://github.com/lajos/iFrameExtractor&quot;&gt;https://github.com/lajos/iFrameExtractor&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ffmpeg的简介&quot;&gt;ffmpeg的简介&lt;/h2&gt;

&lt;p&gt;FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。&lt;/p&gt;

&lt;p&gt;“FFmpeg”这个单词中的”FF”指的是”Fast Forward”。&lt;/p&gt;

&lt;h6 id=&quot;ffmpeg支持的格式&quot;&gt;ffmpeg支持的格式&lt;/h6&gt;

&lt;p&gt;ASF&lt;/p&gt;

&lt;p&gt;AVI&lt;/p&gt;

&lt;p&gt;BFI&lt;/p&gt;

&lt;p&gt;FLV&lt;/p&gt;

&lt;p&gt;GXF, General eXchange Format, SMPTE 360M&lt;/p&gt;

&lt;p&gt;IFF&lt;/p&gt;

&lt;p&gt;RL2&lt;/p&gt;

&lt;p&gt;ISO base media file format（包括QuickTime, 3GP和MP4）&lt;/p&gt;

&lt;p&gt;Matroska（包括WebM）&lt;/p&gt;

&lt;p&gt;Maxis XA&lt;/p&gt;

&lt;p&gt;MPEG program stream&lt;/p&gt;

&lt;p&gt;MPEG transport stream（including AVCHD）&lt;/p&gt;

&lt;p&gt;MXF, Material eXchange Format, SMPTE 377M&lt;/p&gt;

&lt;p&gt;MSN Webcam stream&lt;/p&gt;

&lt;p&gt;Ogg&lt;/p&gt;

&lt;p&gt;OMA&lt;/p&gt;

&lt;p&gt;TXD&lt;/p&gt;

&lt;p&gt;WTV&lt;/p&gt;

&lt;h6 id=&quot;ffmpeg支持的协议&quot;&gt;ffmpeg支持的协议&lt;/h6&gt;

&lt;p&gt;IETF标准：TCP, UDP, Gopher, HTTP, RTP, RTSP和SDP&lt;/p&gt;

&lt;p&gt;苹果公司的相关标准：HTTP Live Streaming&lt;/p&gt;

&lt;p&gt;RealMedia的相关标准：RealMedia RTSP/RDT&lt;/p&gt;

&lt;p&gt;Adobe的相关标准：RTMP, RTMPT（由librtmp实现），RTMPE（由librtmp实现），RTMPTE（由librtmp）和RTMPS（由librtmp实现）&lt;/p&gt;

&lt;p&gt;微软的相关标准：MMS在TCP上和MMS在HTTP上&lt;/p&gt;

&lt;h2 id=&quot;iframeextractor的使用&quot;&gt;iFrameExtractor的使用&lt;/h2&gt;

&lt;p&gt;初始化&lt;/p&gt;
&lt;pre&gt;
self.video = [[VideoFrameExtractor alloc] initWithVideo:[Utilities bundlePath:@&quot;sophie.mov&quot;]];

	video.outputWidth = 426;
	video.outputHeight = 320;
&lt;/pre&gt;

&lt;p&gt;播放&lt;/p&gt;

&lt;pre&gt;
	[video seekTime:0.0];
	[NSTimer scheduledTimerWithTimeInterval:1.0/30
									 target:self
								   selector:@selector(displayNextFrame:)
								   userInfo:nil
									repeats:YES];
&lt;/pre&gt;

&lt;pre&gt;
-(void)displayNextFrame:(NSTimer *)timer {
	if (![video stepFrame]) {

		return;
	}
	imageView.image = video.currentImage;

}
&lt;/pre&gt;

&lt;h2 id=&quot;videoframeextractor类解析&quot;&gt;VideoFrameExtractor类解析&lt;/h2&gt;

&lt;h6 id=&quot;initwithvideonsstring-moviepath方法&quot;&gt;initWithVideo:(NSString *)moviePath方法&lt;/h6&gt;

&lt;p&gt;VideoFrameExtractor的初始化，主要是配置三个全局的结构体变量。&lt;/p&gt;

&lt;p&gt;AVFormatContext类型的pFormatCtx，AVFormatContext主要存储视音频封装格式中包含的信息；AVInputFormat存储输入视音频使用的封装格式。每种视音频封装格式都对应一个AVInputFormat 结构。&lt;/p&gt;

&lt;p&gt;AVCodecContext类型的pCodecCtx ，每个AVStream存储一个视频/音频流的相关数据；每个AVStream对应一个AVCodecContext，存储该视频/音频流使用解码方式的相关数据；每个AVCodecContext中对应一个AVCodec，包含该视频/音频对应的解码器。每种解码器都对应一个AVCodec结构。&lt;/p&gt;

&lt;p&gt;AVFrame类型的pFrame，视频的话，每个结构一般是存一帧，音频可能有好几帧。解码前数据是AVPacket，解码后数据是AVFrame。&lt;/p&gt;

&lt;p&gt;FMPEG中结构体很多。最关键的结构体他们之间的对应关系如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130914204051125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; width=&quot;440&quot; height=&quot;179&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图片来自:&lt;a href=&quot;http://blog.csdn.net/leixiaohua1020/article/details/11693997&quot;&gt;FFMPEG中最关键的结构体之间的关系&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面就是初始化的代码&lt;/p&gt;
&lt;pre&gt;
-(id)initWithVideo:(NSString *)moviePath {
	if (!(self=[super init])) return nil;
 
    AVCodec         *pCodec;
		
    // Register all formats and codecs
    avcodec_register_all();
    av_register_all();
	
    // Open video file
    if(avformat_open_input(&amp;amp;pFormatCtx, [moviePath cStringUsingEncoding:NSASCIIStringEncoding], NULL, NULL) != 0) {
        av_log(NULL, AV_LOG_ERROR, &quot;Couldn't open file\n&quot;);
        goto initError;
    }
	
    // Retrieve stream information
    if(avformat_find_stream_info(pFormatCtx,NULL) &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &quot;Couldn't find stream information\n&quot;);
        goto initError;
    }
    
    // Find the first video stream
    if ((videoStream =  av_find_best_stream(pFormatCtx, AVMEDIA_TYPE_VIDEO, -1, -1, &amp;amp;pCodec, 0)) &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &quot;Cannot find a video stream in the input file\n&quot;);
        goto initError;
    }
	
    // Get a pointer to the codec context for the video stream
    pCodecCtx = pFormatCtx-&amp;gt;streams[videoStream]-&amp;gt;codec;
    
    // Find the decoder for the video stream
    pCodec = avcodec_find_decoder(pCodecCtx-&amp;gt;codec_id);
    if(pCodec == NULL) {
        av_log(NULL, AV_LOG_ERROR, &quot;Unsupported codec!\n&quot;);
        goto initError;
    }
	
    // Open codec
    if(avcodec_open2(pCodecCtx, pCodec, NULL) &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &quot;Cannot open video decoder\n&quot;);
        goto initError;
    }
	
    // Allocate video frame
    pFrame = avcodec_alloc_frame();
			
	outputWidth = pCodecCtx-&amp;gt;width;
	self.outputHeight = pCodecCtx-&amp;gt;height;
			
	return self;
	
initError:
	[self release];
	return nil;
}
&lt;/pre&gt;

&lt;h6 id=&quot;sourcewidth和sourceheight方法&quot;&gt;sourceWidth和sourceHeight方法&lt;/h6&gt;

&lt;p&gt;获取屏幕的宽和高&lt;/p&gt;
&lt;pre&gt;
-(int)sourceWidth {
	return pCodecCtx-&amp;gt;width;
}

-(int)sourceHeight {
	return pCodecCtx-&amp;gt;height;
}

&lt;/pre&gt;

&lt;h6 id=&quot;setupscaler方法&quot;&gt;setupScaler方法&lt;/h6&gt;

&lt;p&gt;设置视频播放视图的尺寸&lt;/p&gt;
&lt;pre&gt;
-(void)setupScaler {

	// Release old picture and scaler
	avpicture_free(&amp;amp;picture);
	sws_freeContext(img_convert_ctx);	
	
	// Allocate RGB picture
	avpicture_alloc(&amp;amp;picture, PIX_FMT_RGB24, outputWidth, outputHeight);
	
	// Setup scaler
	static int sws_flags =  SWS_FAST_BILINEAR;
	img_convert_ctx = sws_getContext(pCodecCtx-&amp;gt;width, 
									 pCodecCtx-&amp;gt;height,
									 pCodecCtx-&amp;gt;pix_fmt,
									 outputWidth, 
									 outputHeight,
									 PIX_FMT_RGB24,
									 sws_flags, NULL, NULL, NULL);
	
}
&lt;/pre&gt;

&lt;h6 id=&quot;duration方法&quot;&gt;duration方法&lt;/h6&gt;

&lt;p&gt;获取音视频文件的总时间&lt;/p&gt;
&lt;pre&gt;
-(double)duration {
	return (double)pFormatCtx-&amp;gt;duration / AV_TIME_BASE;
}
&lt;/pre&gt;

&lt;h6 id=&quot;currenttime方法&quot;&gt;currentTime方法&lt;/h6&gt;

&lt;p&gt;显示音视频当前播放的时间&lt;/p&gt;
&lt;pre&gt;
-(double)currentTime {
    AVRational timeBase = pFormatCtx-&amp;gt;streams[videoStream]-&amp;gt;time_base;
    return packet.pts * (double)timeBase.num / timeBase.den;
}
&lt;/pre&gt;

&lt;h6 id=&quot;seektimedoubleseconds方法&quot;&gt;seekTime:(double)seconds方法&lt;/h6&gt;

&lt;p&gt;直接跳到音视频的第seconds秒进行播放，默认从第0.0秒开始&lt;/p&gt;
&lt;pre&gt;
-(void)seekTime:(double)seconds {
	AVRational timeBase = pFormatCtx-&amp;gt;streams[videoStream]-&amp;gt;time_base;
	int64_t targetFrame = (int64_t)((double)timeBase.den / timeBase.num * seconds);
	avformat_seek_file(pFormatCtx, videoStream, targetFrame, targetFrame, targetFrame, AVSEEK_FLAG_FRAME);
	avcodec_flush_buffers(pCodecCtx);
}
&lt;/pre&gt;

&lt;h6 id=&quot;stepframe方法&quot;&gt;stepFrame方法&lt;/h6&gt;

&lt;p&gt;解码视频得到帧&lt;/p&gt;
&lt;pre&gt;
-(BOOL)stepFrame {
	// AVPacket packet;
    int frameFinished=0;

    while(!frameFinished &amp;amp;&amp;amp; av_read_frame(pFormatCtx, &amp;amp;packet)&amp;gt;=0) {
        // Is this a packet from the video stream?
        if(packet.stream_index==videoStream) {
            // Decode video frame
            avcodec_decode_video2(pCodecCtx, pFrame, &amp;amp;frameFinished, &amp;amp;packet);
        }
		
	}
	return frameFinished!=0;
}
&lt;/pre&gt;

&lt;h6 id=&quot;currentimage方法&quot;&gt;currentImage方法&lt;/h6&gt;

&lt;p&gt;获取当前的UIImage对象，以呈现当前播放的画面&lt;/p&gt;
&lt;pre&gt;
-(UIImage *)currentImage {
	if (!pFrame-&amp;gt;data[0]) return nil;
	[self convertFrameToRGB];
	return [self imageFromAVPicture:picture width:outputWidth height:outputHeight];
}

&lt;/pre&gt;

&lt;h6 id=&quot;convertframetorgb&quot;&gt;convertFrameToRGB&lt;/h6&gt;

&lt;p&gt;转换音视频帧到RGB&lt;/p&gt;
&lt;pre&gt;
-(void)convertFrameToRGB {	
	sws_scale (img_convert_ctx, pFrame-&amp;gt;data, pFrame-&amp;gt;linesize,
			   0, pCodecCtx-&amp;gt;height,
			   picture.data, picture.linesize);	
}

&lt;/pre&gt;

&lt;h6 id=&quot;uiimage-imagefromavpictureavpicturepict-widthintwidth-heightintheight方法&quot;&gt;(UIImage *)imageFromAVPicture:(AVPicture)pict width:(int)width height:(int)height方法&lt;/h6&gt;

&lt;p&gt;把AVPicture转换成UIImage把音视频画面显示出来&lt;/p&gt;
&lt;pre&gt;
-(UIImage *)imageFromAVPicture:(AVPicture)pict width:(int)width height:(int)height {
	CGBitmapInfo bitmapInfo = kCGBitmapByteOrderDefault;
	CFDataRef data = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, pict.data[0], pict.linesize[0]*height,kCFAllocatorNull);
	CGDataProviderRef provider = CGDataProviderCreateWithCFData(data);
	CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
	CGImageRef cgImage = CGImageCreate(width, 
									   height, 
									   8, 
									   24, 
									   pict.linesize[0], 
									   colorSpace, 
									   bitmapInfo, 
									   provider, 
									   NULL, 
									   NO, 
									   kCGRenderingIntentDefault);
	CGColorSpaceRelease(colorSpace);
	UIImage *image = [UIImage imageWithCGImage:cgImage];
	CGImageRelease(cgImage);
	CGDataProviderRelease(provider);
	CFRelease(data);
	
	return image;
}
&lt;/pre&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderyi/Eleven&quot;&gt;ElevenPlayer&lt;/a&gt;: 这是我用ffmpeg写的iOS万能播放器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cnbin.github.io/blog/2015/05/19/iospei-zhi-ffmpegkuang-jia/&quot;&gt;iOS配置FFmpeg框架&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/FFmpeg&quot;&gt;FFmpeg-wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.vitamio.org/docs/Basic/2013/0508/14.html&quot;&gt;Vitamio测试网络视频地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/leixiaohua1020/article/details/14214577&quot;&gt; FFMPEG结构体分析-系列文章&lt;/a&gt;:包括AVFrame、AVFormatContext、AVCodecContext、AVIOContext、AVCodec、AVStream、AVPacket&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/column/details/ffmpeg-devel.html&quot;&gt;FFmpeg开发和使用有关的文章的汇总&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.ffmpeg.org/&quot;&gt;ffmpeg 官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/FFmpeg/FFmpeg&quot;&gt;FFmpeg GitHub source code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者 ：&lt;a href=&quot;https://github.com/coderyi/blog&quot;&gt;coderyi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;转载请加原文链接:&lt;a href=&quot;https://github.com/coderyi/blog/blob/master/articles/2015/0826_ffmpeg_iOS_iframeextractor.md&quot;&gt;https://github.com/coderyi/blog/blob/master/articles/2015/0826_ffmpeg_iOS_iframeextractor.md&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 26 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/ffmpeg_iOS_iframeextractor/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/ffmpeg_iOS_iframeextractor/</guid>
        
        <category>音视频</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>iOS与Android的音频互通</title>
        <description>&lt;p&gt;2015-06-08&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #3d82c6;&quot;&gt;音频的基本知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;声音是波的一种，频率和振幅是描述波的重要属性，频率的大小与我们通常所说的音高对应，而振幅影响声音的大小。频率的单位是赫兹，赫兹是电、磁、声波和机械振动周期循环时频率的单位，即每秒的周期次数(周期/秒)。对于声音，人类的听觉范围为20Hz～20000Hz，低于这个范围叫做次声波，高于这个范围的叫做超声波。&lt;/p&gt;

&lt;p&gt;数码录音最关键一步就是要把模拟信号转换为数码信号，就电脑而言是把模拟声音信号录制成为音频文件。&lt;/p&gt;

&lt;p&gt;描述音频文件主要有两个指标，一个是采样频率，或称采样率、采率，另一个是采样精度也就是比特率。&lt;/p&gt;

&lt;p&gt;采样，指把时间域或空间域的连续量转化成离散量的过程。每秒钟的采样样本数叫做采样频率。采样频率越高，数字化后声波就越接近于原来的波形，即声音的保真度越高，但量化后声音信息量的存储量也越大，而人的耳朵已经很难分辨。根据采样定理，只有当采样频率高于声音信号最高频率的两倍时，才能把离散模拟信号表示的声音信号唯一地还原成原来的声音。我们最常用的采样频率是44.1kHz，它的意思是每秒取样44100次。&lt;/p&gt;

&lt;p&gt;比特率是指每秒传送的比特(bit)数，单位为 bps(Bit Per Second)。比特率越高，传送数据速度越快。声音中的比特率是指将模拟声音信号转换成数字声音信号后，单位时间内的二进制数据量。比特率其实就是表示振幅，比特率越大，能够表示声音的响度越清晰。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #3d82c6;&quot;&gt;iOS音频的基础&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接着我们要整体了解下iOS为我们提供处理音频的基础技术，核心音频（Core Audio）。&lt;/p&gt;

&lt;p&gt;Core Audio 是IOS和 MAC 的关于数字音频处理的基础，它提供应用程序用来处理音频的一组软件框架，所有关于IOS音频开发的接口都是由Core Audio来提供或者经过它提供的接口来进行封装的，按照官方的说法是集播放，音频处理录制为一体的专业技术，通过它我们的程序可以同时录制，播放一个或者多个音频流，自动适应耳机，蓝牙耳机等硬件，响应各种电话中断，静音，震动等，甚至提供3D效果的音乐播放。&lt;/p&gt;

&lt;p&gt;Core Audio有5个框架：1.Core Audio.framework，2.AudioToolbox.framework，3.AudioUnit.framework ，4.AVFoundation.framework，5.OpenAL.framework。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/GooHong/article/details/28911301&quot;&gt;参考:iOS框架和服务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Core Audio.framework并不提供服务，仅提供其他框架可以使用的头文件和数据类型。这其中AVFoundation 框架 (AVFoundation.framework)提供一组播放、记录和管理声音和视频内容的Objective-C类，因此下面我就简单介绍一下他就可以了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #3d82c6;&quot;&gt;AVFoundation的录音和播放&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;音频的录制与播放主要和三个类有关AVAudioSession，AVAudioRecorder，AVAudioPlayer。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AVAudioSession&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AVAudioSession类由AVFoundation框架引入，每个iOS应用都有一个音频会话，这个会话可以被AVAudioSession类的sharedInstance类方法访问，如下：&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; style=&quot;background: #E8F2FB;&quot;&gt;AVAudioSession *audioSession = [AVAudioSession sharedInstance];&lt;/pre&gt;

&lt;p&gt;在获得一个AVAudioSession类的实例后，你就能通过调用音频会话对象的setCategory:error:实例方法，来从IOS应用可用的不同类别中作出选择。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AVAudioRecorder&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在使用AVAudioRecorder进行音频录制的时候，需要设置一些参数，下面就是参数的说明，并且写下了音频录制的代码：&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; style=&quot;background: #E8F2FB;&quot;&gt;//音频开始录制
- (void)startRecordWithFilePath:(NSString *)path{
    [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayAndRecord error:nil];
    [[AVAudioSession sharedInstance] setActive:YES error:nil];

    /**
     *
     AVFormatIDKey  音乐格式，这里采用PCM格式
     AVSampleRateKey 采样率
     AVNumberOfChannelsKey 音乐通道数
     AVLinearPCMBitDepthKey,采样位数 默认 16
     AVLinearPCMIsFloatKey,采样信号是整数还是浮点数
     AVLinearPCMIsBigEndianKey,大端还是小端 是内存的组织方式
     AVEncoderAudioQualityKey,音频编码质量

     */

    NSDictionary *recordSetting = @{
                                    AVFormatIDKey               : @(kAudioFormatLinearPCM),
                                    AVSampleRateKey             : @(8000.f),
                                    AVNumberOfChannelsKey       : @(1),
                                    AVLinearPCMBitDepthKey      : @(16),
                                    AVLinearPCMIsNonInterleaved : @NO,
                                    AVLinearPCMIsFloatKey       : @NO,
                                    AVLinearPCMIsBigEndianKey   : @NO
                                    };

    //初始化录音
    self.recorder = [[AVAudioRecorder alloc]initWithURL:[NSURL URLWithString:path]
                                                settings:recordSetting
                                                   error:nil];
    _recorder.delegate = self;
    _recorder.meteringEnabled = YES;

    [_recorder prepareToRecord];
    [_recorder record];
}

//音频停止录制
- (void)stopRecord
{

    [self.recorder stop];
    self.recorder = nil;

}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AVAudioPlayer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AVAudioPlayer类是音频播放的类，一个AVAudioPlayer只能播放一个音频，如果你想混音你可以创建多个AVAudioPlayer实例，每个相当于混音板上的一个轨道，下面就是音频播放的方法。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; style=&quot;background: #E8F2FB;&quot;&gt;//音频开始播放

- (void)startPlayAudioFile:(NSString *)fileName{
    //初始化播放器
    player = [[AVAudioPlayer alloc]init];

    player = [player initWithContentsOfURL:[NSURL URLWithString:fileName] error:nil];
    self.player.delegate = self;
    [player play];


}

//音频停止播放
- (void)stopPlay{
    if (self.player) {
        [self.player stop];
        self.player.delegate = nil;
        self.player = nil;
    }
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #3d82c6;&quot;&gt;转码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面我们用iOS录制了一个音频文件，并且录制成了wav格式，然而现在的情况确实安卓不支持wav格式，并且苹果的格式安卓全不支持，看好是全不，不是全部，反过来安卓的格式，苹果基本也不支持。&lt;/p&gt;

&lt;p&gt;这里可以让服务器去转码，不过服务器的压力会增加，这里我们可以让客户端进行转码。amr格式的音频文件是安卓系统中默认的录音文件，也算是安卓支持的很方便的音频文件，这里就把iOS录制的wav文件转成amr，我们采用的是libopencore框架。
关于libopencore，&lt;a title=&quot;Jeans&quot; href=&quot;http://my.oschina.net/jeans&quot;&gt;Jeans&lt;/a&gt;有对它进行了一个比较好的Demo，大家可以参考他的Demo，&lt;a title=&quot;iOS音频格式AMR和WAV互转（支持64位）&quot; href=&quot;http://www.oschina.net/code/snippet_562429_12400&quot;&gt;iOS音频格式AMR和WAV互转（支持64位）&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在他的AmrWavConverter代码Demo里面有掩饰这两个转码工作。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; style=&quot;background: #E8F2FB;&quot;&gt;//转换amr到wav
+ (int)ConvertAmrToWav:(NSString *)aAmrPath wavSavePath:(NSString *)aSavePath{

    if (! DecodeAMRFileToWAVEFile([aAmrPath cStringUsingEncoding:NSASCIIStringEncoding], [aSavePath cStringUsingEncoding:NSASCIIStringEncoding]))
        return 0;

    return 1;
}

//转换wav到amr
+ (int)ConvertWavToAmr:(NSString *)aWavPath amrSavePath:(NSString *)aSavePath{

    if (! EncodeWAVEFileToAMRFile([aWavPath cStringUsingEncoding:NSASCIIStringEncoding], [aSavePath cStringUsingEncoding:NSASCIIStringEncoding], 1, 16))
        return 0;

    return 1;
}
&lt;/pre&gt;
&lt;p&gt;转载请附原文地址&lt;a title=&quot;https://github.com/coderyi/blog/blob/master/articles/2015/0608_audio.md&quot; href=&quot;https://github.com/coderyi/blog/blob/master/articles/2015/0608_audio.md&quot;&gt;https://github.com/coderyi/blog/blob/master/articles/2015/0608_audio.md&lt;/a&gt; 。&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/iOS_android_audio/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/iOS_android_audio/</guid>
        
        <category>音视频</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>iOS的SQLite简单使用</title>
        <description>&lt;p&gt;2015-01-16&lt;/p&gt;

&lt;p&gt;SQLite，是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。它能够支持Windows/Linux/Unix等等主流的操作系统，同时能够跟很多程序语言相结合，比如 Tcl、C#、PHP、Java等，还有ODBC接口，同样比起Mysql、PostgreSQL这两款开源的世界著名数据库管理系统来讲，它的处理速度比他们都快。SQLite第一个Alpha版本诞生于2000年5月。 至今已经有14个年头，SQLite也迎来了一个版本 SQLite 3已经发布。&lt;/p&gt;

&lt;h3&gt;SQLite的特性&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ACID事务&lt;br /&gt;ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）. 原子性意味着数据库中的事务执行是作为原子。即不可再分，整个语句要么执行，要么不执行。一致性指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;零配置 – 无需安装和管理配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;储存在单一磁盘文件中的一个完整的数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库文件可以在不同字节顺序的机器间自由的共享&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持数据库大小至2TB&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;足够小, 大致13万行C代码, 4.43M&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;比一些流行的数据库在大部分普通数据库操作要快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简单, 轻松的API&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;包含TCL绑定, 同时通过Wrapper支持其他语言的绑定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;良好注释的源代码, 并且有着90%以上的测试覆盖率&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;独立，没有额外依赖&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源码完全的开源, 你可以用于任何用途, 包括出售它&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持多种开发语言,C, PHP, Perl, Java, C#,Python, Ruby&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;SQLite在iOS中的基本使用&lt;/h3&gt;

&lt;p&gt;在iOS开发中可以用一些SQLite数据库管理工具，例如SQLiteManager。&lt;/p&gt;

&lt;p&gt;接下来就通过代码来讲述iOS中如何使用sqlite&lt;/p&gt;

&lt;p&gt;sqlite.h文件的引入&lt;/p&gt;

&lt;p&gt;首先是打开和关闭数据库，打开和创建数据库都是sqlite3_open函数，如果filename已经创建那就是打开。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; escaped=&quot;true&quot; style=&quot;background: #E8F2FB ;&quot;&gt;
NSString *filename;//数据库文件路径
sqlite3 *database; //sqlite3数据库句柄的指针
//打开数据库
- (int) open{
    int rc=sqlite3_open([filename UTF8String], &amp;amp;database);
    if (rc) {
        sqlite3_close(database);
        NSLog(@&quot;open database failed&quot;);
    }
    return rc;
}
//关闭数据库
- (void) close{
    if (database!=NULL) {
        sqlite3_close(database);
    }
}
&lt;/pre&gt;
&lt;p&gt;接下来插入、删除、更新都是用sqlite3_exec函数，记住执行语句，必须要先打开数据库，完成之后需要关闭数据库。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; escaped=&quot;true&quot; style=&quot;background: #E8F2FB ;&quot;&gt;
//执行 insert,update,delete 等非查询SQL语句
 - (int)executeNonQuery:(NSString *)sql error:(NSError **)error {
     int rc;
     char *errmsg;
     rc = [self open];
     if (rc) {
//错误处理
     if (error != NULL) {
         NSDictionary *eDict =
         [NSDictionary dictionaryWithObject:@&quot;open database failed&quot;
         forKey:NSLocalizedDescriptionKey];
         *error =
         [NSError errorWithDomain:kSqliteErrorDomain code:rc userInfo:eDict];
     }
     return rc;
 }
     rc = sqlite3_exec(database, [sql UTF8String], NULL, NULL, &amp;amp;errmsg);
     if (rc != SQLITE_OK) {
         if (error != NULL) {
             NSDictionary *eDict =
             [NSDictionary dictionaryWithObject:@&quot;exec sql error&quot;
             forKey:NSLocalizedDescriptionKey];
             *error =
             [NSError errorWithDomain:kSqliteErrorDomain code:rc userInfo:eDict];
         }
         NSLog(@&quot;%s&quot;, errmsg);
         sqlite3_free(errmsg);
     }
     [self close];
     return rc;
 }&lt;/pre&gt;
&lt;p&gt;上面函数中sqlite3_free就是释放存放错误信息的内存空间。
查询操作会略显复杂，同样需要有开关数据库的操作，不过有一个准备结果集和最后释放结果集的操作，分别是sqlite3_prepare_v2和sqlite3_finalize，sqlite3_stmt就是结果集，下面就是具体操作。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; escaped=&quot;true&quot; style=&quot;background: #E8F2FB ;&quot;&gt;[self open];
 // 查
 strsql = &quot;select * from users&quot;;
 // SQLITE_API int sqlite3_prepare_v2(
 // sqlite3 *db, /* Database handle */
 // const char *zSql, /* SQL statement*/
 // int nByte, /* 结果集的最大长度。*/
 // sqlite3_stmt **ppStmt, /* OUT: 结果集 */
 // const char **pzTail /* OUT:指向结果集没有用到的内存部分的指针。 */
 // );
 sqlite3_stmt* rc;//陈述式句柄
 if (sqlite3_prepare_v2(db, strsql, -1, &amp;amp;rc, NULL)!=SQLITE_OK) {
 }
 // sqlite3_step讲结果集数据指针指向下一个元素。
 // 这个函数的返回值如果是SQLITE_ROW就表示我们的结果集里面有数据。
 // 否则我们的结果集就是空的。
 while (sqlite3_step(rc)==SQLITE_ROW) {
 // sqlite3_column系列函数。一般有两个输入参数。第一个是结果集指针，第二是数据所在列的序号。
 // 比如我们现在用的sqlite3_column_int和sqlite3_column_text。
    printf(&quot;id:%d | username:%s | password:%s \n&quot;,sqlite3_column_int(rc,               0),sqlite3_column_text(rc, 1),sqlite3_column_text(rc, 2));

 }
 // 查完后一定要释放结果集。
 sqlite3_finalize(rc);
 [self close];&lt;/pre&gt;
&lt;h3&gt;数据库加密&lt;/h3&gt;

&lt;p&gt;免费版的SQLite有一个致命缺点：不支持加密。这就导致存储在SQLite中的数据可以被任何人用任何文本编辑器查看到。&lt;/p&gt;

&lt;p&gt;对数据库加密的思路有两种：&lt;/p&gt;

&lt;p&gt;1.将内容加密后再写入数据库&lt;/p&gt;

&lt;p&gt;这种方式使用简单，在入库/出库只需要将字段做对应的加解密操作即可，一定程度上解决了将数据赤裸裸暴露的问题。
不过这种方式并不是彻底的加密，因为数据库的表结构等信息还是能被查看到。另外写入数据库的内容加密后，搜索也是个问题。&lt;/p&gt;

&lt;p&gt;2.对数据库文件加密&lt;/p&gt;

&lt;p&gt;将整个数据库整个文件加密，这种方式基本上能解决数据库的信息安全问题。目前已有的SQLite加密基本都是通过这种方式实现的。这里就介绍一个开源的加密工具SQLCipher，安装方法可以参照官网文档，&lt;a href=&quot;https://www.zetetic.net/sqlcipher/ios-tutorial/&quot; title=&quot;https://www.zetetic.net/sqlcipher/ios-tutorial/&quot;&gt;https://www.zetetic.net/sqlcipher/ios-tutorial/&lt;/a&gt;，SQLCipher使用256-bit AES加密，由于其基于免费版的SQLite，主要的加密接口和SQLite是相同的，但也增加了一些自己的接口。&lt;/p&gt;

&lt;p&gt;其实SQLite的两个加密函数使用起来非常的简单，下面分情况说明：&lt;/p&gt;

&lt;p&gt;1 给一个未加密的数据库添加密码：如果想要添加密码，则可以在打开数据库文件之后，关闭数据库文件之前的任何时刻调用sqlite3_key函数即可，该函数有三个参数，其中第一个参数为数据库对象，第二个参数是要设定的密码，第三个是密码的长度。例如：sqlite3_key(db,”1q2w3e4r”,8); //给数据库设定密码1q2w3e4r&lt;/p&gt;

&lt;p&gt;2 读取一个加密数据库中的数据：完成这个任务依然十分简单，你只需要在打开数据库之后，再次调用一下sqlite3_key函数即可，例如，数据库密码是123456时，你只需要在代码中加入sqlite3_key(db,”123456”,6);&lt;/p&gt;

&lt;p&gt;3更改数据库密码：首先你需要使用当前的密码正确的打开数据库，之后你可以调用sqlite3_rekey(db,”112233”,6) 来更改数据库密码。&lt;/p&gt;

&lt;p&gt;4 删除密码：也就是把数据库恢复到明文状态。这时你仍然只需要调用sqlite3_rekey函数，并且把该函数的第二个参数置为NULL或者”“,或者把第三个参数设为0。&lt;/p&gt;

&lt;h3&gt;事务操作&lt;/h3&gt;

&lt;p&gt;那么问题又来了，如果iOS的sqlite同时插入或者查询10000条数据，你该怎么办？&lt;/p&gt;

&lt;p&gt;这里有三步要做，第一，减少开关数据库操作，插入10000条数据，不能开关10000次数据库，只能进行一次开关；&lt;/p&gt;

&lt;p&gt;第二，就是不能放在主线程；&lt;/p&gt;

&lt;p&gt;第三，最重要的一点就是加入事务操作。&lt;/p&gt;

&lt;p&gt;事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在sqlite插入数据的时候默认一条语句就是一个事务，有多少条数据就有多少次磁盘操作。所以10000次磁盘操作可能几分钟都做不完，这个时候需要把10000条语句都封装成一个事务。&lt;/p&gt;

&lt;p&gt;下面就是开始事务和提交事务的代码了&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; escaped=&quot;true&quot; style=&quot;background: #E8F2FB ;&quot;&gt;
-(int)beginService{
     char *errmsg;
     int rc = sqlite3_exec(database, &quot;BEGIN transaction&quot;, NULL, NULL, &amp;amp;errmsg);
     return rc;
 }
-(int)commitService{
     char *errmsg;
     int rc = sqlite3_exec(database, &quot;COMMIT transaction&quot;, NULL, NULL, &amp;amp;errmsg);
     return rc;
}&lt;/pre&gt;
&lt;p&gt;接下来就把三个操作合并&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; escaped=&quot;true&quot; style=&quot;background: #E8F2FB ;&quot;&gt;-(int)addModelsTest:(NSArray *)models error:(NSError **) error{
     char *errmsg;
     __block NSMutableArray *sqls=[NSMutableArray array];
     __block NoticeModel *aModel=[[NoticeModel alloc] init];
     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
         for (int i=0; i&amp;lt;100000; i++) {
             aModel=[models objectAtIndex:0];
             NSString *sql=[NSString stringWithFormat:@&quot;insert into notices     values('%lf','%d','%@','%@','%@','%d','%d','%d','%d','%@')&quot;,aModel.myID,aModel.news_id,aModel.news_title,aModel.content,aModel.pic,aModel.sort,aModel.record_status,aModel.counter,aModel.suid,aModel.publish_time];
             [sqls addObject:sql];
         }
         int r1=[self open];
         [self beginService];
         int rc;
         int i;
         for (i=0; i&amp;lt;100000; i++) {
             rc=sqlite3_exec(database, [[sqls objectAtIndex:i] UTF8String], NULL, NULL, &amp;amp;errmsg);
         }
         [self commitService];
         [self close];
         if (i ==100000) {
             dispatch_async(dispatch_get_main_queue(), ^{
                 NSLog(@&quot;call back, the data is: %@&quot;, i);
             });
         } else {
             NSLog(@&quot;error when download:%@&quot;, error);
         }
     });
     return 0;
 }&lt;/pre&gt;
</description>
        <pubDate>Fri, 16 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/SQLite/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/SQLite/</guid>
        
        <category>数据库</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>iOS蓝牙4.0协议简单介绍</title>
        <description>&lt;p&gt;iOS开发蓝牙4.0的框架是CoreBluetooth，本文主要介绍CoreBluetooth的使用，关于本文中的代码片段大多来自github上的一个demo，地址是&lt;a title=&quot;myz1104/Bluetooth&quot; href=&quot;https://github.com/myz1104/Bluetooth&quot;&gt;myz1104/Bluetooth&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在CoreBluetooth中有两个主要的部分,Central和Peripheral，有一点类似Client Server。CBPeripheralManager 作为周边设备是服务器。CBCentralManager作为中心设备是客户端。所有可用的iOS设备可以作为周边（Peripheral）也可以作为中央（Central），但不可以同时既是周边也是中央。&lt;/p&gt;

&lt;p&gt;一般手机是客户端， 设备（比如手环）是服务器，因为是手机去连接手环这个服务器。周边（Peripheral）是生成或者保存了数据的设备，中央（Central）是使用这些数据的设备。你可以认为周边是一个广播数据的设备，他广播到外部世界说他这儿有数据，并且也说明了能提供的服务。另一边，中央开始扫描附近有没有服务，如果中央发现了想要的服务，然后中央就会请求连接周边，一旦连接建立成功，两个设备之间就开始交换传输数据了。&lt;/p&gt;

&lt;p&gt;除了中央和周边，我们还要考虑他俩交换的数据结构。这些数据在服务中被结构化，每个服务由不同的特征（Characteristics）组成，特征是包含一个单一逻辑值的属性类型。&lt;/p&gt;

&lt;h3&gt;Peripheral的实现步骤&lt;/h3&gt;

&lt;p&gt;首先是创建一个周边&lt;/p&gt;

&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;_peripheralManager = [[CBPeripheralManager alloc]initWithDelegate:self queue:nil];&lt;/pre&gt;
&lt;p&gt;接下来它就会响应代理的peripheralManagerDidUpdateState方法，可以获得peripheral的状态等信息，&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral
{
    switch (peripheral.state)
    {
        case CBPeripheralManagerStatePoweredOn:
        {
            [self setupService];
        }
            break;

        default:
        {
            NSLog(@&quot;Peripheral Manager did change state&quot;);
        }
            break;
    }
}
&lt;/pre&gt;
&lt;p&gt;当发现周边设备的蓝牙是可以的时候，这就需要去准备你需要广播给其他中央设备的服务和特征了，这里通过调用setupService方法来实现。
每一个服务和特征都需要用一个UUID（unique identifier）去标识，UUID是一个16bit或者128bit的值。如果你要创建你的中央-周边App，你需要创建你自己的128bit的UUID。你必须要确定你自己的UUID不能和其他已经存在的服务冲突。如果你正要创建一个自己的设备，需要实现标准委员会需求的UUID；如果你只是创建一个中央-周边App，我建议你打开Mac OS X的Terminal.app，用uuidgen命令生成一个128bit的UUID。你应该用该命令两次，生成两个UUID，一个是给服务用的，一个是给特征用的。然后，你需要添加他们到中央和周边App中。现在，在view controller的实现之前，我们添加以下的代码：&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;static NSString * const kServiceUUID = @&quot;1C85D7B7-17FA-4362-82CF-85DD0B76A9A5&quot;;
static NSString * const kCharacteristicUUID = @&quot;7E887E40-95DE-40D6-9AA0-36EDE2BAE253&quot;;
&lt;/pre&gt;
&lt;p&gt;下面就是setupService方法&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)setupService
{
    CBUUID *characteristicUUID = [CBUUID UUIDWithString:kCharacteristicUUID];

    self.customCharacteristic = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable];

    CBUUID *serviceUUID = [CBUUID UUIDWithString:kServiceUUID];

    self.customService = [[CBMutableService alloc] initWithType:serviceUUID primary:YES];
    [self.customService setCharacteristics:@[self.customCharacteristic]];
    [self.peripheralManager addService:self.customService];


}
&lt;/pre&gt;
&lt;p&gt;当调用了CBPeripheralManager的addService方法后，这里就会响应CBPeripheralManagerDelegate的- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error方法。这个时候就可以开始广播我们刚刚创建的服务了。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error
{
    if (error == nil)
    {
        [self.peripheralManager startAdvertising:@{ CBAdvertisementDataLocalNameKey : @&quot;ICServer&quot;, CBAdvertisementDataServiceUUIDsKey : @[[CBUUID UUIDWithString:kServiceUUID]] }];
    }
}&lt;/pre&gt;
&lt;p&gt;当然到这里，你已经做完了peripheralManager的工作了，中央设备已经可以接受到你的服务了。不过这是静止的数据，你还可以调用- (BOOL)updateValue:(NSData *)value forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:(NSArray *)centrals方法可以给中央生成动态数据的地方。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)sendToSubscribers:(NSData *)data {
  if (self.peripheral.state != CBPeripheralManagerStatePoweredOn) {
    LXCBLog(@&quot;sendToSubscribers: peripheral not ready for sending state: %d&quot;, self.peripheral.state);
    return;
  }

  BOOL success = [self.peripheral updateValue:data
                            forCharacteristic:self.characteristic
                         onSubscribedCentrals:nil];
  if (!success) {
    LXCBLog(@&quot;Failed to send data, buffering data for retry once ready.&quot;);
    self.pendingData = data;
    return;
  }
}&lt;/pre&gt;
&lt;p&gt;central订阅了characteristic的值，当更新值的时候peripheral会调用updateValue: forCharacteristic: onSubscribedCentrals:(NSArray*)centrals去为数组里面的centrals更新对应characteristic的值，在更新过后peripheral为每一个central走一遍下面的代理方法&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&lt;/pre&gt;
&lt;p&gt;peripheral接受到一个读或者写的请求时，会响应以下两个代理方法&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request

- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray *)requests&lt;/pre&gt;
&lt;p&gt;那么现在peripheral就已经创建好了。&lt;/p&gt;
&lt;h3&gt;创建一个中央&lt;/h3&gt;
&lt;p&gt;创建中央并且连接周边
现在，我们已经有了一个周边，让我们创建我们的中央。中央就是那个处理周边发送来的数据的设备。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;self.manager = [[CBCentralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue()];&lt;/pre&gt;
&lt;p&gt;当Central Manager被初始化，我们要检查它的状态，以检查运行这个App的设备是不是支持BLE。实现CBCentralManagerDelegate的代理方法：&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)centralManagerDidUpdateState:(CBCentralManager *)central
{
    switch (central.state)
    {
        case CBCentralManagerStatePoweredOn:
        {
            [self.manager scanForPeripheralsWithServices:@[ [CBUUID UUIDWithString:kServiceUUID]]
                                                 options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }];
        }
            break;
        default:
        {
            NSLog(@&quot;Central Manager did change state&quot;);
        }
            break;
    }
}&lt;/pre&gt;
&lt;p&gt;当app的设备是支持蓝牙的时候，需要调用CBCentralManager实例的- (void)scanForPeripheralsWithServices:(NSArray *)serviceUUIDs options:(NSDictionary *)options方法，用来寻找一个指定的服务的peripheral。一旦一个周边在寻找的时候被发现，中央的代理会收到以下回调：&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI
{

    NSString *UUID = [peripheral.identifier UUIDString];
    NSString *UUID1 = CFBridgingRelease(CFUUIDCreateString(NULL, peripheral.UUID));
    NSLog(@&quot;----发现外设----%@%@&quot;, UUID,UUID1);
    [self.manager stopScan];

    if (self.peripheral != peripheral)
    {
        self.peripheral = peripheral;
        NSLog(@&quot;Connecting to peripheral %@&quot;, peripheral);
        [self.manager connectPeripheral:peripheral options:nil];
    }
}&lt;/pre&gt;
&lt;p&gt;这个时候一个附带着广播数据和信号质量(RSSI-Received Signal Strength Indicator)的周边被发现。这是一个很酷的参数，知道了信号质量，你可以用它去判断远近。任何广播、扫描的响应数据保存在advertisementData 中，可以通过CBAdvertisementData 来访问它。
这个时候你用可以连接这个周边设备了，&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;[self.manager connectPeripheral:peripheral options:nil];&lt;/pre&gt;
&lt;p&gt;它会响应下面的代理方法，&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{
    NSLog(@&quot;----成功连接外设----&quot;);
    [self.peripheral setDelegate:self];
    [self.peripheral discoverServices:@[ [CBUUID UUIDWithString:kServiceUUID]]];
}&lt;/pre&gt;
&lt;p&gt;访问周边的服务
上面的CBCentralManagerDelegate代理会返回CBPeripheral实例，它的- (void)discoverServices:(NSArray *)serviceUUIDs方法就是访问周边的服务了，这个方法会响应CBPeripheralDelegate的方法。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheral:(CBPeripheral *)aPeripheral didDiscoverServices:(NSError *)error
{
    NSLog(@&quot;----didDiscoverServices----Error:%@&quot;,error);
    if (error)
    {
        NSLog(@&quot;Error discovering service: %@&quot;, [error localizedDescription]);
        [self cleanup];
        return;
    }

    for (CBService *service in aPeripheral.services)
    {
        NSLog(@&quot;Service found with UUID: %@&quot;, service.UUID);
        if ([service.UUID isEqual:[CBUUID UUIDWithString:kServiceUUID]])
        {
            [self.peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:kCharacteristicUUID],[CBUUID UUIDWithString:kWrriteCharacteristicUUID]] forService:service];
        }
    }
}&lt;/pre&gt;
&lt;p&gt;在上面的方法中如果没有error，可以调用discoverCharacteristics方法请求周边去寻找它的服务所列出的特征，它会响应下面的方法&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error
{
    if (error)
    {
        NSLog(@&quot;Error discovering characteristic: %@&quot;, [error localizedDescription]);
        return;
    }
    if ([service.UUID isEqual:[CBUUID UUIDWithString:kServiceUUID]])
    {
        for (CBCharacteristic *characteristic in service.characteristics)
        {
            NSLog(@&quot;----didDiscoverCharacteristicsForService---%@&quot;,characteristic);
            if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:kCharacteristicUUID]])
            {
                [peripheral readValueForCharacteristic:characteristic];
                [peripheral setNotifyValue:YES forCharacteristic:characteristic];
            }

            if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:kWrriteCharacteristicUUID]])
            {
                writeCharacteristic = characteristic;
            }

        }
    }
}&lt;/pre&gt;
&lt;p&gt;这个时候peripheral可以调用两个方法，
[peripheral readValueForCharacteristic:characteristic]这个是读特征值的，会响应- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error；&lt;/p&gt;

&lt;p&gt;[peripheral setNotifyValue:YES forCharacteristic:characteristic];会响应- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error；&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    if (error)
    {
        NSLog(@&quot;Error changing notification state: %@&quot;, error.localizedDescription);
    }

    // Exits if it's not the transfer characteristic
    if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:kCharacteristicUUID]] )
    {
        // Notification has started
        if (characteristic.isNotifying)
        {
            NSLog(@&quot;Notification began on %@&quot;, characteristic);
            [peripheral readValueForCharacteristic:characteristic];
        }
        else
        { // Notification has stopped
            // so disconnect from the peripheral
            NSLog(@&quot;Notification stopped on %@.  Disconnecting&quot;, characteristic);
            [self.manager cancelPeripheralConnection:self.peripheral];
        }
    }
}

- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    NSLog(@&quot;----Value---%@&quot;,characteristic.value);
    if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:kCharacteristicUUID]])
    {

        if (writeCharacteristic)
        {
            Byte ACkValue[3] = {0};
            ACkValue[0] = 0xe0; ACkValue[1] = 0x00; ACkValue[2] = ACkValue[0] + ACkValue[1];
            NSData *data = [NSData dataWithBytes:&amp;amp;ACkValue length:sizeof(ACkValue)];
            [self.peripheral writeValue:data
                      forCharacteristic:writeCharacteristic
                                   type:CBCharacteristicWriteWithoutResponse];
        }
    }
}&lt;/pre&gt;
&lt;p&gt;在上面的方法中，- (void)writeValue:(NSData *)data forCharacteristic:(CBCharacteristic *)characteristic type:(CBCharacteristicWriteType)type是一个对周边设备写数据的方法，它会响应下面的方法&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    NSLog(@&quot;---didWriteValueForCharacteristic-----&quot;);
    if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:kWrriteCharacteristicUUID]])
    {
        NSLog(@&quot;----value更新----&quot;);

    }
}&lt;/pre&gt;
&lt;p&gt;这样，中央设备也实现了读写数据的功能了。&lt;/p&gt;

&lt;p&gt;另外，github上有一个封装的第三方开源蓝牙框架，地址是&lt;a title=&quot;kickingvegas/YmsCoreBluetooth&quot; href=&quot;https://github.com/kickingvegas/YmsCoreBluetooth&quot;&gt;kickingvegas/YmsCoreBluetooth&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/CoreBluetooth/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/CoreBluetooth/</guid>
        
        <category>网络通信</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>iOS的xmppframework简介</title>
        <description>&lt;p&gt;2014-12-13&lt;/p&gt;

&lt;p&gt;1登录和好友上下线&lt;/p&gt;

&lt;p&gt;1.1XMPP中常用对象们&lt;/p&gt;

&lt;p&gt;XMPPStream：xmpp基础服务类&lt;/p&gt;

&lt;p&gt;XMPPRoster：好友列表类&lt;/p&gt;

&lt;p&gt;XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类&lt;/p&gt;

&lt;p&gt;XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类&lt;/p&gt;

&lt;p&gt;XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它&lt;/p&gt;

&lt;p&gt;xmppvCardAvatarModule：好友头像&lt;/p&gt;

&lt;p&gt;XMPPReconnect：如果失去连接,自动重连&lt;/p&gt;

&lt;p&gt;XMPPRoom：提供多用户聊天支持&lt;/p&gt;

&lt;p&gt;XMPPPubSub：发布订阅&lt;/p&gt;

&lt;p&gt;1.2登录操作，也就是连接xmpp服务器&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)connect {
    if (self.xmppStream == nil) {
        self.xmppStream = [[XMPPStream alloc] init];
        [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
    }
    if (![self.xmppStream isConnected]) {
        NSString *username = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;username&quot;];
        XMPPJID *jid = [XMPPJID jidWithUser:username domain:@&quot;lizhen&quot; resource:@&quot;Ework&quot;];
        [self.xmppStream setMyJID:jid];
        [self.xmppStream setHostName:@&quot;10.4.125.113&quot;];
        NSError *error = nil;
        if (![self.xmppStream connect:&amp;amp;error]) {
            NSLog(@&quot;Connect Error: %@&quot;, [[error userInfo] description]);
        }
    }
}&lt;/pre&gt;
&lt;p&gt;connect成功之后&lt;/p&gt;

&lt;p&gt;会依次调用XMPPStreamDelegate的方法，&lt;/p&gt;

&lt;p&gt;首先调用&lt;/p&gt;
&lt;pre&gt;- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket&lt;/pre&gt;

&lt;p&gt;然后&lt;/p&gt;
&lt;pre&gt;
- (void)xmppStreamDidConnect:(XMPPStream *)sender&lt;/pre&gt;

&lt;p&gt;在该方法下面需要使用xmppStream 的authenticateWithPassword方法进行密码验证，成功的话会响应delegate的方法，就是下面这个&lt;/p&gt;

&lt;pre&gt;- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&lt;/pre&gt;

&lt;p&gt;1.3上线&lt;/p&gt;

&lt;p&gt;实现 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender 委托方法&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
    XMPPPresence *presence = [XMPPPresence presenceWithType:@&quot;available&quot;];
    [self.xmppStream sendElement:presence];
}&lt;/pre&gt;
&lt;p&gt;1.4退出并断开连接&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)disconnect {
    XMPPPresence *presence = [XMPPPresence presenceWithType:@&quot;unavailable&quot;];
    [self.xmppStream sendElement:presence];

    [self.xmppStream disconnect];
}&lt;/pre&gt;

&lt;p&gt;1.5好友状态&lt;/p&gt;

&lt;p&gt;获取好友状态，通过实现&lt;/p&gt;
&lt;pre&gt;- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence&lt;/pre&gt;
&lt;p&gt;方法&lt;/p&gt;

&lt;p&gt;当接收到 &lt;presence&gt;&lt;/presence&gt; 标签的内容时，XMPPFramework 框架回调该方法&lt;/p&gt;

&lt;p&gt;一个 &lt;presence&gt;&lt;/presence&gt; 标签的格式一般如下：&lt;/p&gt;
&lt;pre lang=&quot;xml&quot; line=&quot;1&quot;&gt;
&amp;lt;presence from=&quot;&quot;&amp;gt;
　　&amp;lt;show&amp;gt;这里是显示的内容&amp;lt;show /&amp;gt;
　　&amp;lt;status&amp;gt;这里是显示的状态&amp;lt;status /&amp;gt;
&amp;lt;presence /&amp;gt;&lt;/pre&gt;
&lt;p&gt;presence 的状态：&lt;/p&gt;

&lt;p&gt;available 上线&lt;/p&gt;

&lt;p&gt;away 离开&lt;/p&gt;

&lt;p&gt;do not disturb 忙碌&lt;/p&gt;

&lt;p&gt;unavailable 下线&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence {
    NSString *presenceType = [presence type];
    NSString *presenceFromUser = [[presence from] user];
    if (![presenceFromUser isEqualToString:[[sender myJID] user]]) {
        if ([presenceType isEqualToString:@&quot;available&quot;]) {
            //
        } else if ([presenceType isEqualToString:@&quot;unavailable&quot;]) {
            //
        }
    }
}&lt;/pre&gt;
&lt;p&gt;2接收消息和发送消息
2.1接收消息&lt;/p&gt;

&lt;p&gt;通过实现&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message;
方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当接收到 &lt;message&gt;&lt;/message&gt; 标签的内容时，XMPPFramework 框架回调该方法&lt;/p&gt;

&lt;p&gt;根据 XMPP 协议，消息体的内容存储在标签 &amp;lt;body /&amp;gt; 内&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message {
    NSString *messageBody = [[message elementForName:@&quot;body&quot;] stringValue];
}&lt;/pre&gt;
&lt;p&gt;2.2发送消息&lt;/p&gt;

&lt;p&gt;发送消息，我们需要根据 XMPP 协议，将数据放到 &lt;message&gt;&lt;/message&gt; 标签内，例如：&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;&amp;lt;message type=&quot;chat&quot; to=&quot;xiaoming@example.com&quot;&amp;gt;
　　&amp;lt;body&amp;gt;Hello World!&amp;lt;body /&amp;gt;
&amp;lt;message /&amp;gt;&lt;/pre&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)sendMessage:(NSString *) message toUser:(NSString *) user {
    NSXMLElement *body = [NSXMLElement elementWithName:@&quot;body&quot;];
    [body setStringValue:message];
    NSXMLElement *message = [NSXMLElement elementWithName:@&quot;message&quot;];
    [message addAttributeWithName:@&quot;type&quot; stringValue:@&quot;chat&quot;];
    NSString *to = [NSString stringWithFormat:@&quot;%@@example.com&quot;, user];
    [message addAttributeWithName:@&quot;to&quot; stringValue:to];
    [message addChild:body];
    [self.xmppStream sendElement:message];
}&lt;/pre&gt;
&lt;p&gt;3获取好友信息和删除好友
3.1好友列表和好友名片&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;[_xmppRoster fetchRoster];//获取好友列表
//获取到一个好友节点
- (void)xmppRoster:(XMPPRoster *)sender didRecieveRosterItem:(NSXMLElement *)item
//获取完好友列表
- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender
//到服务器上请求联系人名片信息
- (void)fetchvCardTempForJID:(XMPPJID *)jid;
//请求联系人的名片，如果数据库有就不请求，没有就发送名片请求
- (void)fetchvCardTempForJID:(XMPPJID *)jid ignoreStorage:(BOOL)ignoreStorage;
//获取联系人的名片，如果数据库有就返回，没有返回空，并到服务器上抓取
- (XMPPvCardTemp *)vCardTempForJID:(XMPPJID *)jid shouldFetch:(BOOL)shouldFetch;
//更新自己的名片信息
- (void)updateMyvCardTemp:(XMPPvCardTemp *)vCardTemp;
//获取到一盒联系人的名片信息的回调
- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule
        didReceivevCardTemp:(XMPPvCardTemp *)vCardTemp
                     forJID:(XMPPJID *)jid&lt;/pre&gt;
&lt;p&gt;3.2添加好友&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;//name为用户账号
    - (void)XMPPAddFriendSubscribe:(NSString *)name
    {
        //XMPPHOST 就是服务器名，  主机名
        XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@&quot;%@@%@&quot;,name,XMPPHOST]];
        //[presence addAttributeWithName:@&quot;subscription&quot; stringValue:@&quot;好友&quot;];
        [xmppRoster subscribePresenceToUser:jid];

    }&lt;/pre&gt;

&lt;p&gt;3.3收到添加好友的请求&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence
    {
        //取得好友状态
        NSString *presenceType = [NSString stringWithFormat:@&quot;%@&quot;, [presence type]]; //online/offline
        //请求的用户
        NSString *presenceFromUser =[NSString stringWithFormat:@&quot;%@&quot;, [[presence from] user]];
        NSLog(@&quot;presenceType:%@&quot;,presenceType);
        NSLog(@&quot;presence2:%@  sender2:%@&quot;,presence,sender);
        XMPPJID *jid = [XMPPJID jidWithString:presenceFromUser];
        //接收添加好友请求
        [xmppRoster acceptPresenceSubscriptionRequestFrom:jid andAddToRoster:YES];
    }&lt;/pre&gt;
&lt;p&gt;3.4删除好友&lt;/p&gt;

&lt;p&gt;//删除好友，name为好友账号&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)removeBuddy:(NSString *)name
{
    XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@&quot;%@@%@&quot;,name,XMPPHOST]];

    [self xmppRoster] removeUser:jid];
}&lt;/pre&gt;
&lt;p&gt;4聊天室
    //初始化聊天室&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
    XMPPJID *roomJID = [XMPPJID jidWithString:ROOM_JID];

    xmppRoom = [[XMPPRoom alloc] initWithRoomStorage:self jid:roomJID];

    [xmppRoom activate:xmppStream];
    [xmppRoom addDelegate:self delegateQueue:dispatch_get_main_queue()];&lt;/pre&gt;
&lt;p&gt;//创建聊天室成功&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
 -(void)xmppRoomDidCreate:(XMPPRoom *)sender
    {
        DDLogInfo(@&quot;%@: %@&quot;, THIS_FILE, THIS_METHOD);
    }&lt;/pre&gt;
&lt;p&gt;//加入聊天室，使用昵称&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt; [xmppRoom joinRoomUsingNickname:@&quot;quack&quot; history:nil];&lt;/pre&gt;
&lt;p&gt;//获取聊天室信息&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
 - (void)xmppRoomDidJoin:(XMPPRoom *)sender
    {
        [xmppRoom fetchConfigurationForm];
        [xmppRoom fetchBanList];
        [xmppRoom fetchMembersList];
        [xmppRoom fetchModeratorsList];
    }&lt;/pre&gt;

&lt;p&gt;如果房间存在，会调用委托&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
    // 收到禁止名单列表
    - (void)xmppRoom:(XMPPRoom *)sender didFetchBanList:(NSArray *)items;
    // 收到好友名单列表
    - (void)xmppRoom:(XMPPRoom *)sender didFetchMembersList:(NSArray *)items;
    // 收到主持人名单列表
    - (void)xmppRoom:(XMPPRoom *)sender didFetchModeratorsList:(NSArray *)items;&lt;/pre&gt;
&lt;p&gt;房间不存在，调用委托&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchBanList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchMembersList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchModeratorsList:(XMPPIQ *)iqError;&lt;/pre&gt;
&lt;p&gt;离开房间&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
[xmppRoom deactivate:xmppStream];&lt;/pre&gt;
&lt;p&gt;XMPPRoomDelegate的其他代理方法&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//离开聊天室
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)xmppRoomDidLeave:(XMPPRoom *)sender
    {
        DDLogVerbose(@&quot;%@: %@&quot;, THIS_FILE, THIS_METHOD);
    }&lt;/pre&gt;
&lt;p&gt;//新人加入群聊&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)xmppRoom:(XMPPRoom *)sender occupantDidJoin:(XMPPJID *)occupantJID
    {
        DDLogVerbose(@&quot;%@: %@&quot;, THIS_FILE, THIS_METHOD);
    }
&lt;/pre&gt;
&lt;p&gt;//有人退出群聊&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt; - (void)xmppRoom:(XMPPRoom *)sender occupantDidLeave:(XMPPJID *)occupantJID
    {
        DDLogVerbose(@&quot;%@: %@&quot;, THIS_FILE, THIS_METHOD);
    }&lt;/pre&gt;

&lt;p&gt;//有人在群里发言&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt; - (void)xmppRoom:(XMPPRoom *)sender didReceiveMessage:(XMPPMessage *)message fromOccupant:(XMPPJID *)occupantJID
    {
        DDLogVerbose(@&quot;%@: %@&quot;, THIS_FILE, THIS_METHOD);
    }&lt;/pre&gt;
&lt;p&gt;5消息回执
这个是XEP－0184协议的内容&lt;/p&gt;

&lt;p&gt;协议内容：&lt;/p&gt;

&lt;p&gt;发送消息时附加回执请求&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
    &amp;lt;message
    from='northumberland@shakespeare.lit/westminster'
    id='richard2-4.1.247'
    to='kingrichard@royalty.england.lit/throne'&amp;gt;
        &amp;lt;body&amp;gt;My lord, dispatch; read o'er these articles.&amp;lt;/body&amp;gt;
        &amp;lt;request xmlns='urn:xmpp:receipts'/&amp;gt;
    &amp;lt;/message&amp;gt;&lt;/pre&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
    NSString *siID = [XMPPStream generateUUID];
    //发送消息
    XMPPMessage *message = [XMPPMessage messageWithType:@&quot;chat&quot; to:jid elementID:siID];
    NSXMLElement *receipt = [NSXMLElement elementWithName:@&quot;request&quot; xmlns:@&quot;urn:xmpp:receipts&quot;];
    [message addChild:receipt];
    [message addBody:@&quot;测试&quot;];
    [self.xmppStream sendElement:message];&lt;/pre&gt;
&lt;p&gt;收到回执请求的消息，发送回执&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;
    &amp;lt;message
    from='kingrichard@royalty.england.lit/throne'
    id='bi29sg183b4v'
    to='northumberland@shakespeare.lit/westminster'&amp;gt;
        &amp;lt;received xmlns='urn:xmpp:receipts' id='richard2-4.1.247'/&amp;gt;
    &amp;lt;/message&amp;gt;&lt;/pre&gt;

&lt;p&gt;代码实现&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
    {
        //回执判断
        NSXMLElement *request = [message elementForName:@&quot;request&quot;];
        if (request)
        {
            if ([request.xmlns isEqualToString:@&quot;urn:xmpp:receipts&quot;])//消息回执
            {
                //组装消息回执
                XMPPMessage *msg = [XMPPMessage messageWithType:[message attributeStringValueForName:@&quot;type&quot;] to:message.from elementID:[message attributeStringValueForName:@&quot;id&quot;]];
                NSXMLElement *recieved = [NSXMLElement elementWithName:@&quot;received&quot; xmlns:@&quot;urn:xmpp:receipts&quot;];
                [msg addChild:recieved];

                //发送回执
                [self.xmppStream sendElement:msg];
            }
        }else
        {
            NSXMLElement *received = [message elementForName:@&quot;received&quot;];
            if (received)
            {
                if ([received.xmlns isEqualToString:@&quot;urn:xmpp:receipts&quot;])//消息回执
                {
                    //发送成功
                    NSLog(@&quot;message send success!&quot;);
                }
            }
        }

        //消息处理
        //...  &lt;/pre&gt;
&lt;p&gt;6添加AutoPing
为了监听服务器是否有效，增加心跳监听。用XEP-0199协议，在XMPPFrameWork框架下，封装了 XMPPAutoPing 和 XMPPPing两个类都可以使用，因为XMPPAutoPing已经组合进了XMPPPing类，所以XMPPAutoPing使用起来更方便。&lt;/p&gt;
&lt;pre lang=&quot;objc&quot; line=&quot;1&quot;&gt;//初始化并启动ping
-(void)autoPingProxyServer:(NSString*)strProxyServer
{
    _xmppAutoPing = [[XMPPAutoPingalloc] init];
    [_xmppAutoPingactivate:_xmppStream];
    [_xmppAutoPingaddDelegate:selfdelegateQueue:  dispatch_get_main_queue()];
    _xmppAutoPing.respondsToQueries = YES;
    _xmppAutoPing.pingInterval=2;//ping 间隔时间
    if (nil != strProxyServer)
    {
       _xmppAutoPing.targetJID = [XMPPJID jidWithString: strProxyServer ];//设置ping目标服务器，如果为nil,则监听socketstream当前连接上的那个服务器
    }
}
//卸载监听
 [_xmppAutoPing   deactivate];
 [_xmppAutoPing   removeDelegate:self];
 _xmppAutoPing = nil;
//ping XMPPAutoPingDelegate的委托方法:
- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender
{
    NSLog(@&quot;- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender&quot;);
}
- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender
{
    NSLog(@&quot;- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender&quot;);
}

- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender
{
    NSLog(@&quot;- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender&quot;);
}&lt;/pre&gt;

&lt;p&gt;如果想要学习更多XMPPFramework的东西，我以前看过一个比较全面的demo，地址：&lt;a href=&quot;http://code4app.com/ios/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F1.2/535651f2933bf0647d8b570f&quot; title=&quot;即时通讯群聊系统&quot;&gt;即时通讯群聊系统&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/xmppframework/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/xmppframework/</guid>
        
        <category>网络通信</category>
        
        
        <category>iOS</category>
        
      </item>
    
  </channel>
</rss>
